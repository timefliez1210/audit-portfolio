# [000652] User loses complete access to all vested tokens in mergeTVS()
  
  ### Summary

An NFT holder will suffer complete token loss as they can accidentally or maliciously merge their destination NFT into itself, burning the certificate needed to prove ownership while allocation data remains inaccessible

### Root Cause

In `AlignerzVesting.sol:mergeTVS()` ([lines ~1530â€“1570](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1002C3-L1048C6)), there is a lack of validation preventing an NFT ID from being included in both the destination (`mergedNftId`) and source (`nftIds[]`) arrays simultaneously

### Internal Pre-conditions

1. User needs to call `mergeTVS()` with `mergedNftId` included in the `nftIds[]` array

2. User must own the NFT to initiate the merge------


### External Pre-conditions

_No response_

### Attack Path

1. User holds NFT #100 with 1000 tokens allocated

2. User calls `mergeTVS(projectId, 100, [0], [100])` (destination and source both = 100)

3. `_merge()` processes the self-copy, then burns NFT #100 via `nftContract.burn(100)`

4. Allocation data remains but `claimTokens()` will fail because `extOwnerOf(100)` now reverts (NFT no longer exists)### [C-01] User loses complete access to all vested tokens### [C-01] Merge NFT Self-Destruct Vulnerability - Permanent Loss of Vesting Rights

### Impact

The user suffers an approximate loss of 100% of their vested tokens, becoming permanently inaccessible. No recovery mechanism exists.


### PoC

```solidity
 function test_PoC_merge_self_destruct() public {
        // 1) Project owner launches a reward project and allocates TVS to this test contract
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);

        address[] memory kols = new address[](1);
        kols[0] = address(this);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 100 ether;

        // projectCreator has approved token transfers in setUp
        vm.prank(projectCreator);
        vesting.setTVSAllocation(0, 100 ether, 30 days, kols, amounts);

        // 2) Record minted count, then claim as the KOL to receive an NFT
        uint256 before = nft.getTotalMinted();
        vm.prank(address(this));
        vesting.claimRewardTVS(0);
        uint256 afterClaim = nft.getTotalMinted();
        assertEq(afterClaim, before + 1, "NFT not minted");

        uint256 nftId = before; // mint returns startToken == previous total minted

        // Sanity: we own the NFT
        assertEq(nft.ownerOf(nftId), address(this));

        // 3) Call mergeTVS but include mergedNftId in the nftIds list to trigger self-burn
        uint256[] memory projectIds = new uint256[](1);
        uint256[] memory nftIds = new uint256[](1);
        projectIds[0] = 0;
        nftIds[0] = nftId;

        // This call will perform _merge on the same NFT and call burn(nftId)
        vm.prank(address(this));
        vesting.mergeTVS(0, nftId, projectIds, nftIds);

        // After merge, NFT should be burned - ownerOf should revert. Use try/catch to assert revert.
        bool burned = false;
        try nft.ownerOf(nftId) returns (address) {
            burned = false;
        } catch {
            burned = true;
        }

        assertTrue(burned, "NFT was not burned - vulnerability not reproduced");
    }
```

### Mitigation

```solidity

for (uint256 i; i < nbOfNFTs; i++) {1. User needs to call `mergeTVS()` with `mergedNftId` included in the `nftIds[]` array1. The destination NFT's allocation flows are merged into itself (self-copy)

    require(nftIds[i] != mergedNftId, "Cannot_Merge_NFT_Into_Itself");

    require(projectIds[i] == projectId, "Project_Id_Mismatch");2. User must own the NFT to initiate the merge2. `_merge()` then burns the NFT by calling `nftContract.burn(nftId)` where `nftId == mergedNftId`

    feeAmount += _merge(mergedTVS, projectIds[i], nftIds[i], token);

}

```
  