# [001032] Inverted Token Filter Logic Causes Complete Dividend Misdirection to Wrong Token Holders
  
  ### Summary

An inverted boolean condition in the token filtering logic will cause a complete misdirection of dividend distributions for legitimate TVS holders as the dividend distributor will exclude all NFTs vesting the intended token while including NFTs vesting unrelated tokens from different projects, resulting in 100% of dividends being allocated to holders of wrong tokens.

### Root Cause

In `A26ZDividendDistributor.sol` the equality [check](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol#L141) `if (address(token) == address(vesting.allocationOf(nftId).token)) return 0;` is inverted. The function returns 0 when the NFT's vested token matches the distributor's configured token, which causes eligible NFTs to be excluded from dividend calculations. Conversely, NFTs vesting different tokens pass this check and have their unclaimed amounts calculated and included, directing dividends to holders of unrelated project tokens instead of the intended beneficiaries.

### Internal Pre-conditions

1. Owner needs to call `setUpTheDividends()` or `setDividends()` to trigger the dividend allocation process after stablecoins have been deposited into the contract.
2. The contract needs to have a non-zero stablecoin balance to distribute as dividends to TVS holders.
3. Multiple NFTs need to exist in the system, with at least one NFT vesting the token that matches the distributor's configured token address and at least one NFT vesting a different token from another project.

### External Pre-conditions

None required.

### Attack Path

1. The A26ZDividendDistributor contract is deployed with token set to the address of the $A26Z `token`, intended to distribute dividends to $A26Z TVS holders.
2. Users hold various NFTs in the system, where NFT 1 and NFT 2 vest $A26Z tokens with 1,000 and 2,000 unclaimed tokens respectively, and NFT 3 vests $SONIC tokens from a different project with 1,500 unclaimed tokens.
3. The contract receives 100 USDC in stablecoins designated as dividend payments for $A26Z TVS holders.
4. Owner calls `setUpTheDividends()` which internally calls `_setAmounts()` to calculate the total unclaimed amounts.
5. The `getTotalUnclaimedAmounts()` function loops through all NFTs and calls `getUnclaimedAmounts(nftId)` for each.
6. For NFT 1, the function executes `if (address($A26Z) == address($A26Z))` which evaluates to true, causing the function to return 0 and set `unclaimedAmountsIn[1] = 0`.
7. For NFT 2, the same logic applies and `unclaimedAmountsIn[2] = 0`.
8. For NFT 3, the function executes `if (address($A26Z) == address($SONIC))` which evaluates to false, allowing the function to proceed with calculating the 1,500 unclaimed $SONIC tokens and set `unclaimedAmountsIn[3] = 1500`.
9. The totalUnclaimedAmounts becomes 1,500 (only counting the $SONIC NFT), and _setDividends() is called.
10. In _setDividends(), the dividend allocation formula `dividendsOf[owner].amount += (unclaimedAmountsIn[i] * stablecoinAmountToDistribute / totalUnclaimedAmounts)` results in NFT 1 owner receiving 0 USDC, NFT 2 owner receiving 0 USDC, and NFT 3 owner receiving the full 100 USDC despite holding a completely different project's token.
11. When users claim their dividends via `claimDividends()`, the $A26Z holders receive nothing while the $SONIC holder successfully claims all 100 USDC.

### Impact

The legitimate $A26Z TVS holders suffer a 100% loss of their entitled dividend distributions. The holders of NFTs vesting unrelated project tokens incorrectly gain the full dividend amount that was designated for $A26Z holders. This completely breaks the dividend distribution mechanism described in the whitepaper section 5.2, where dividends should be "redistributed directly to our TVS holders, proportionally to their locked tokens." The system becomes fundamentally broken as each project-specific dividend distributor will allocate funds to holders of every other project except the intended one.

### PoC

Save the following as `test/DividendLogicInversionTest.t.sol:`

forge test --match-contract DividendLogicInversionTest --match-test testInvertedLogicCausesDividendMisdirection -vvvv


```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import "../src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol";
import "../src/interfaces/IAlignerzVesting.sol";

contract DividendLogicInversionTest is Test {
    A26ZDividendDistributor public distributor;
    MockVesting public vesting;
    MockNFT public nft;
    MockERC20 public a26zToken;
    MockERC20 public sonicToken;
    MockERC20 public usdc;
    
    address public owner = address(1);
    address public user1 = address(2);
    address public user2 = address(3);
    address public user3 = address(4);

    function setUp() public {
        vm.startPrank(owner);
        
        a26zToken = new MockERC20("A26Z", "A26Z");
        sonicToken = new MockERC20("SONIC", "SONIC");
        usdc = new MockERC20("USDC", "USDC");
        
        nft = new MockNFT();
        vesting = new MockVesting();
        
        distributor = new A26ZDividendDistributor(
            address(vesting),
            address(nft),
            address(usdc),
            block.timestamp,
            90 days,
            address(a26zToken)
        );
        
        vm.stopPrank();
    }

    function testInvertedLogicCausesDividendMisdirection() public {
        vm.startPrank(owner);
        
        nft.mint(user1); // NFT ID 0 - A26Z
        nft.mint(user2); // NFT ID 1 - A26Z
        nft.mint(user3); // NFT ID 2 - SONIC
        
        vesting.setAllocation(0, address(a26zToken), 1000, 500);
        vesting.setAllocation(1, address(a26zToken), 2000, 1000);
        vesting.setAllocation(2, address(sonicToken), 3000, 1500);
        
        usdc.mint(address(distributor), 100e6);
        
        console.log("=== BUG DEMONSTRATION ===");
        console.log("Initial Setup:");
        console.log("- NFT #0: 500 unclaimed A26Z tokens (User1)");
        console.log("- NFT #1: 1000 unclaimed A26Z tokens (User2)");
        console.log("- NFT #2: 1500 unclaimed SONIC tokens (User3)");
        console.log("- Distributor configured for: A26Z token");
        console.log("- Dividend pool: 100 USDC for A26Z holders\n");
        
        uint256 unclaimed0 = distributor.getUnclaimedAmounts(0);
        uint256 unclaimed1 = distributor.getUnclaimedAmounts(1);
        uint256 unclaimed2 = distributor.getUnclaimedAmounts(2);
        
        console.log("Step 1: Calculate unclaimed amounts (THE BUG)");
        console.log("NFT #0 (A26Z holder) calculated unclaimed:", unclaimed0);
        console.log("NFT #1 (A26Z holder) calculated unclaimed:", unclaimed1);
        console.log("NFT #2 (SONIC holder) calculated unclaimed:", unclaimed2);
        console.log("^ BUG: A26Z holders return 0, SONIC holder returns amount!\n");
        
        assertEq(unclaimed0, 0);
        assertEq(unclaimed1, 0);
        assertEq(unclaimed2, 1500);
        
        distributor.setUpTheDividends();
        
        console.log("Step 2: Dividends distributed");
        console.log("Total unclaimed used for distribution: 1500");
        console.log("(But this 1500 is from SONIC, not A26Z!)\n");
        
        vm.stopPrank();
        
        vm.warp(block.timestamp + 91 days);
        
        console.log("Step 3: Users claim dividends");
        
        uint256 user1BalBefore = usdc.balanceOf(user1);
        vm.prank(user1);
        distributor.claimDividends();
        uint256 user1Claimed = usdc.balanceOf(user1) - user1BalBefore;
        
        uint256 user2BalBefore = usdc.balanceOf(user2);
        vm.prank(user2);
        distributor.claimDividends();
        uint256 user2Claimed = usdc.balanceOf(user2) - user2BalBefore;
        
        uint256 user3BalBefore = usdc.balanceOf(user3);
        vm.prank(user3);
        distributor.claimDividends();
        uint256 user3Claimed = usdc.balanceOf(user3) - user3BalBefore;
        
        console.log("User1 (A26Z holder) claimed:", user1Claimed, "USDC");
        console.log("User2 (A26Z holder) claimed:", user2Claimed, "USDC");
        console.log("User3 (SONIC holder) claimed:", user3Claimed, "USDC\n");
        
        assertEq(user1Claimed, 0);
        assertEq(user2Claimed, 0);
        assertEq(user3Claimed, 100e6);
        
        console.log("=== BUG CONFIRMED ===");
        console.log("Expected distribution:");
        console.log("- User1 (500/1500): 33.33 USDC");
        console.log("- User2 (1000/1500): 66.67 USDC");
        console.log("- User3 (SONIC holder): 0 USDC");
        console.log("\nActual distribution:");
        console.log("- User1: 0 USDC (LOSS: 33.33 USDC)");
        console.log("- User2: 0 USDC (LOSS: 66.67 USDC)");
        console.log("- User3: 100 USDC (GAIN: 100 USDC)");
        console.log("\n100% of A26Z dividends went to SONIC token holder!");
    }
}

contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 6;
    mapping(address => uint256) public balanceOf;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) public {
        balanceOf[to] += amount;
    }
    
    function transfer(address to, uint256 amount) public returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function totalSupply() external pure returns (uint256) { return 0; }
    function allowance(address, address) external pure returns (uint256) { return type(uint256).max; }
    function approve(address, uint256) external pure returns (bool) { return true; }
}

contract MockNFT {
    uint256 public totalMinted;
    mapping(uint256 => address) public owners;
    
    function mint(address to) public returns (uint256) {
        owners[totalMinted] = to;
        return totalMinted++;
    }
    
    function getTotalMinted() public view returns (uint256) {
        return totalMinted;
    }
    
    function extOwnerOf(uint256 tokenId) public view returns (address) {
        require(owners[tokenId] != address(0), "Not minted");
        return owners[tokenId];
    }
}

contract MockVesting is IAlignerzVesting {
    mapping(uint256 => Allocation) private _allocations;
    
    function setAllocation(uint256 nftId, address tokenAddr, uint256 totalAmount, uint256 unclaimedAmount) public {
        _allocations[nftId].amounts = new uint256[](1);
        _allocations[nftId].claimedSeconds = new uint256[](1);
        _allocations[nftId].vestingPeriods = new uint256[](1);
        _allocations[nftId].vestingStartTimes = new uint256[](1);
        _allocations[nftId].claimedFlows = new bool[](1);
        
        _allocations[nftId].amounts[0] = totalAmount;
        _allocations[nftId].claimedSeconds[0] = ((totalAmount - unclaimedAmount) * 90 days) / totalAmount;
        _allocations[nftId].vestingPeriods[0] = 90 days;
        _allocations[nftId].vestingStartTimes[0] = block.timestamp;
        _allocations[nftId].claimedFlows[0] = false;
        _allocations[nftId].token = IERC20(tokenAddr);
    }
    
    function allocationOf(uint256 nftId) external view returns (Allocation memory) {
        return _allocations[nftId];
    }
}
```

### Mitigation

Change the equality check to an inequality check in the `getUnclaimedAmounts()` function to properly filter out NFTs that vest different tokens while including NFTs that vest the distributor's configured token.

```solidity
function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
    // Skip NFTs that vest a different token than this distributor manages
    if (address(token) != address(vesting.allocationOf(nftId).token)) return 0;
    
    uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
    uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
    uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
    bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
    uint256 len = vesting.allocationOf(nftId).amounts.length;
    for (uint i; i < len;) {
        if (claimedFlows[i]) continue;
        if (claimedSeconds[i] == 0) {
            amount += amounts[i];
            continue;
        }
        uint256 claimedAmount = claimedSeconds[i] * amounts[i] / vestingPeriods[i];
        uint256 unclaimedAmount = amounts[i] - claimedAmount;
        amount += unclaimedAmount;
        unchecked {
            ++i;
        }
    }
    unclaimedAmountsIn[nftId] = amount;
}
```
  