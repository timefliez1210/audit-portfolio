# [001029] Missing Loop Increment Causes Infinite Loop and Complete DoS of TVS Merge and Split Features
  
  ### Summary

The absence of a loop counter increment statement in the fee calculation function will cause infinite loops and out-of-gas reverts for all users as anyone attempting to merge or split their Tokenized Value Sequencers will trigger the broken function that never exits its iteration loop, resulting in complete denial of service for two core protocol features.

### Root Cause

In `FeesManager.sol` the `calculateFeeAndNewAmountForOneTVS()` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169-L174) contains a for loop that uses the pattern `for (uint256 i; i < length;)` but fails to include the critical increment statement `unchecked { ++i; }` at the end of the loop body. This omission causes the loop counter `i` to remain permanently at its initial value of 0, creating an infinite loop condition where `i < length` evaluates to true indefinitely. The loop body executes repeatedly accessing the same array element at index 0 until the transaction exhausts the block gas limit and reverts. This pattern is inconsistent with all other loops in the codebase which properly include increment statements, indicating this is a coding error rather than intentional design.

### Internal Pre-conditions

1. User needs to own at least one TVS NFT with multiple token flows to have a valid reason to merge or split their position.
2. User needs to call either `mergeTVS()` or `splitTVS()` functions which internally invoke the broken `calculateFeeAndNewAmountForOneTVS()` function to calculate fees.
3. The TVS being processed needs to have at least one unclaimed token flow in its amounts array with length greater than 0 to trigger the loop execution.

### External Pre-conditions

None required. 

### Attack Path

1. User owns TVS NFT with ID 5 containing three separate token flows with amounts of 1000, 2000, and 3000 tokens respectively, representing different vesting schedules that the user wishes to consolidate.
2. User calls `mergeTVS(projectId, mergedNftId, [otherProjectId], [otherNftId])` to merge multiple TVS positions into a single NFT for easier management and reduced gas costs on future claims.
3. The `mergeTVS()` function retrieves `amounts = [1000, 2000, 3000]` from the merged TVS and calculates `nbOfFlows = 3` as the array length.
4. Function calls `calculateFeeAndNewAmountForOneTVS(mergeFeeRate, amounts, nbOfFlows)` passing the merge fee rate of 50 basis points (0.5%) along with the amounts array and length of 3.
5. Inside `calculateFeeAndNewAmountForOneTVS()`, the for loop initializes with `uint256 i = 0` and checks `i < 3` which evaluates to true, entering the loop body.
6. Loop body executes accessing `amounts[0]` which is 1000, calculating fee and updating `feeAmount` and `newAmounts[0]`, but crucially the loop body ends without incrementing i.
7. Loop condition rechecks `i < 3` where i is still 0, evaluating to true again, causing the loop to re-enter and process the same `amounts[0]` element again.
8. This cycle repeats indefinitely with i permanently stuck at 0, causing the same array element to be processed over and over in an infinite loop.
9. After thousands of iterations consuming approximately 30 million gas (the block gas limit), the transaction runs out of gas and reverts with an out-of-gas error.
10. User loses the gas fees paid for the failed transaction (approximately 0.003 ETH at 100 gwei gas price) and their merge operation fails completely, leaving their TVS positions unconsolidated.
11. User attempts to split their TVS instead by calling `splitTVS(projectId, [3000, 4000, 3000], splitNftId)` to divide their position into multiple NFTs with different percentage allocations.
12. The `splitTVS()` function similarly calls `calculateFeeAndNewAmountForOneTVS(splitFeeRate, amounts, nbOfFlows)` with the split fee rate.
13. The same infinite loop occurs in the fee calculation function, causing another out-of-gas revert and gas fee loss for the user.
14. Both merge and split features become completely unusable for all users in the protocol, as every attempt to use these functions results in guaranteed transaction failure and gas loss.

### Impact

All protocol users cannot merge or split their TVS positions, rendering two core features described in the whitepaper section 4.2 completely non-functional. Each user who attempts to use merge or split functionality loses their transaction gas fees (approximately 0.003 to 0.01 ETH per attempt depending on gas prices) with no successful outcome. The protocol loses its competitive advantage of offering flexible TVS management through splitting and merging as promised in the whitepaper, potentially causing users to avoid the platform entirely. With an estimated 1000 users attempting merge operations over the protocol's lifetime, the cumulative gas losses could reach 3 to 10 ETH purely from failed transactions, while the operational impact of having broken core features is immeasurable in terms of reputation damage and lost adoption.

### PoC

Save the following as `test/InfiniteLoopRealTest.t.sol`

forge test --match-contract InfiniteLoopRealTest -vvvv

```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";

contract InfiniteLoopRealTest is Test {
    uint256 constant BASIS_POINT = 10000;
    
    function calculateFeeAmount(uint256 feeRate, uint256 amount) public pure returns (uint256) {
        return (amount * feeRate) / BASIS_POINT;
    }
    
    function calculateFeeAndNewAmountForOneTVS_BUGGY(
        uint256 feeRate, 
        uint256[] memory amounts, 
        uint256 length
    ) public view returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length);
        
        console.log("=== TESTING BUGGY IMPLEMENTATION ===");
        console.log("Fee rate:", feeRate);
        console.log("Array length:", length);
        console.log("");
        
        uint256 iterations = 0;
        for (uint256 i; i < length;) {
            iterations++;
            console.log("Iteration:", iterations);
            console.log("i =", i);
            
            if (iterations > 10) {
                console.log("");
                console.log("STOPPED AFTER 10 ITERATIONS");
                console.log("BUG CONFIRMED: i stuck at", i);
                console.log("Would run infinitely until out of gas!");
                revert("Infinite loop detected");
            }
            
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;
            
            // BUG: Missing increment
            // unchecked { ++i; }
        }
    }
    
    function calculateFeeAndNewAmountForOneTVS_CORRECT(
        uint256 feeRate, 
        uint256[] memory amounts, 
        uint256 length
    ) public view returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length);
        
        console.log("");
        console.log("=== TESTING CORRECT IMPLEMENTATION ===");
        console.log("Fee rate:", feeRate);
        console.log("Array length:", length);
        console.log("");
        
        for (uint256 i; i < length;) {
            console.log("Iteration:", i + 1);
            console.log("i =", i);
            
            uint256 fee = calculateFeeAmount(feeRate, amounts[i]);
            feeAmount += fee;
            newAmounts[i] = amounts[i] - fee;
            
            unchecked { ++i; }
        }
        
        console.log("");
        console.log("Loop completed successfully");
        console.log("Total iterations:", length);
    }
    
    function testBuggyVersion() public {
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1000e18;
        amounts[1] = 2000e18;
        amounts[2] = 3000e18;
        
        uint256 feeRate = 50;
        
        vm.expectRevert("Infinite loop detected");
        this.calculateFeeAndNewAmountForOneTVS_BUGGY(feeRate, amounts, amounts.length);
    }
    
    function testCorrectVersion() public {
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1000e18;
        amounts[1] = 2000e18;
        amounts[2] = 3000e18;
        
        uint256 feeRate = 50;
        
        (uint256 totalFee, uint256[] memory newAmounts) = 
            this.calculateFeeAndNewAmountForOneTVS_CORRECT(feeRate, amounts, amounts.length);
        
        console.log("");
        console.log("=== RESULTS ===");
        console.log("Total fee:", totalFee / 1e18);
        console.log("New amounts:");
        for (uint256 i = 0; i < newAmounts.length; i++) {
            console.log("  [%s]:", i, newAmounts[i] / 1e18);
        }
    }
    
    function testSecondaryBug() public {
        console.log("");
        console.log("=== TESTING SECONDARY BUG ===");
        console.log("Even if increment was present, fee calculation is wrong");
        console.log("");
        
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1000;
        amounts[1] = 2000;
        amounts[2] = 3000;
        
        uint256 feeRate = 100;
        
        uint256 feeAmount;
        uint256[] memory newAmounts = new uint256[](3);
        
        for (uint256 i; i < 3;) {
            uint256 currentFee = (amounts[i] * feeRate) / BASIS_POINT;
            feeAmount += currentFee;
            
            newAmounts[i] = amounts[i] - feeAmount;
            
            console.log("Element [%s]:", i);
            console.log("  Original:", amounts[i]);
            console.log("  Current fee:", currentFee);
            console.log("  Cumulative fee:", feeAmount);
            console.log("  New amount (WRONG):", newAmounts[i]);
            console.log("  Should be:", amounts[i] - currentFee);
            console.log("");
            
            unchecked { ++i; }
        }
        
        console.log("SECONDARY BUG: Each element subtracts cumulative fee!");
    }
}
```

### Mitigation

Add the missing loop increment statement at the end of the loop body in the `calculateFeeAndNewAmountForOneTVS()` function. Additionally, fix the secondary bug by subtracting individual element fees rather than cumulative fees:

```solidity
function calculateFeeAndNewAmountForOneTVS(
    uint256 feeRate, 
    uint256[] memory amounts, 
    uint256 length
) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
    newAmounts = new uint256[](length);
    
    for (uint256 i; i < length;) {
        uint256 currentFee = calculateFeeAmount(feeRate, amounts[i]);
        feeAmount += currentFee;
        newAmounts[i] = amounts[i] - currentFee;  // Subtract individual fee, not cumulative
        
        unchecked { 
            ++i;  // Critical: Add increment statement
        }
    }
}
```

  