# [000645] TVS holders lose orphaned dividends if NFTs are burned between snapshot and distribution
  
  ### Summary

Stablecoin reserved for dividends will remain unallocated in the distributor contract if TVS NFTs are transferred or burned between the snapshot (`setAmounts()`) and distribution (`setDividends()`) steps.

### Root Cause

In `A26ZDividendDistributor.sol` and `AlignerzVesting.sol`, dividend distribution is split across two separate transactions: `_setAmounts()` snapshots totals, then `_setDividends()` distributes using the earlier snapshot. Between these steps, NFTs can be burned (via merge, transfer, or sale), causing the distribution to skip them and leave stablecoin orphaned.

### Internal Pre-conditions

1. Owner needs to call `setAmounts()` to snapshot `stablecoinAmountToDistribute` and populate `unclaimedAmountsIn[]`  

2. One or more NFT holders needs to transfer, merge, or burn their NFTs before `setDividends()` is called

3. Owner needs to call `setDividends()` to distribute using the earlier snapshot

### External Pre-conditions

1. Owner calls `setAmounts()` → snapshots 100 USDC and computes per-NFT shares for 10 active NFTs

2. Before `setDividends()` is called, one NFT holder calls `mergeTVS()` which burns their NFT

3. Owner calls `setDividends()` → iterates remaining 9 NFTs, skips the burned NFT

4. Only 90 USDC is distributed (corresponding to 9 NFTs); 10 USDC remains in contract unassigned}

### Attack Path

1. Owner calls `setAmounts()` → snapshots 100 USDC and computes per-NFT shares for 10 active NFTs

2. Before `setDividends()` is called, one NFT holder calls `mergeTVS()` which burns their NFT

3. Owner calls `setDividends()` → iterates remaining 9 NFTs, skips the burned NFT

4. Only 90 USDC is distributed (corresponding to 9 NFTs); 10 USDC remains in contract unassigned}

### Impact

TVS holders suffer approximately up to ~10% loss of dividend entitlements (proportional to burned NFTs). The protocol's stablecoin is trapped in the distributor contract.

### PoC

```solidity
function test_PoC_dividend_orphaning() public {
        // 1) Launch reward project and allocate to two KOLs
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);

        address k1 = bidders[0];
        address k2 = bidders[1];

        address[] memory kols = new address[](2);
        kols[0] = k1;
        kols[1] = k2;
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 60 ether;
        amounts[1] = 40 ether;

        vm.prank(projectCreator);
        vesting.setTVSAllocation(0, 100 ether, 30 days, kols, amounts);

        // 2) Both KOLs claim their reward NFTs
        uint256 before1 = nft.getTotalMinted();
        vm.prank(k1);
        vesting.claimRewardTVS(0);
        uint256 nft1 = before1;

        uint256 before2 = nft.getTotalMinted();
        vm.prank(k2);
        vesting.claimRewardTVS(0);
        uint256 nft2 = before2;

        // 3) Deploy the dividend distributor and fund it
        A26ZDividendDistributor distributor = new A26ZDividendDistributor(address(vesting), address(nft), address(usdt), block.timestamp, 30 days, address(token));
        usdt.mint(address(distributor), 100 ether);

        // 4) Owner snapshots amounts (setAmounts)
        vm.prank(address(this));
        distributor.setAmounts();

        // 5) Before distribution, transfer nft2 to k1 and merge (simulate cooperative merge)
        vm.prank(k2);
        nft.safeTransferFrom(k2, k1, nft2);

        uint256[] memory projectIds = new uint256[](1);
        uint256[] memory nftIds = new uint256[](1);
        projectIds[0] = 0;
        nftIds[0] = nft2;

        vm.prank(k1);
        vesting.mergeTVS(0, nft1, projectIds, nftIds);

        // 6) Owner performs distribution (setDividends)
        vm.prank(address(this));
        distributor.setDividends();

        // 7) k1 claims his dividends; because nft2 was burned and skipped at distribution time,
        //    not all stablecoinAmountToDistribute will be credited to users -> leftover stays in contract
        uint256 balBefore = usdt.balanceOf(k1);
        vm.prank(k1);
        distributor.claimDividends();
        uint256 balAfter = usdt.balanceOf(k1);
        uint256 claimed = balAfter - balBefore;
        assertTrue(claimed > 0, "k1 should receive some dividends");

        uint256 leftover = usdt.balanceOf(address(distributor));
        // Expect leftover > 0 due to orphaned NFT share
        assertTrue(leftover > 0, "Leftover stablecoin should remain orphaned in distributor");
    }
```

### Mitigation

Make distribution atomic by recomputing totals inside `_setDividends()`:

  