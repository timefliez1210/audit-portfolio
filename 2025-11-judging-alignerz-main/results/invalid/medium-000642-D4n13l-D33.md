# [000642] Timestamp underflow will cause DoS for future-dated vesting schedules as elapsed time calculation subtracts from current time without checking if vesting has started
  
  ### Summary

The missing future-date check in `AlignerzVesting.sol:989` will cause denial of service for queries on vesting schedules that start in the future, as the function calculates `block.timestamp - vestingStartTime` without verifying that `block.timestamp >= vestingStartTime`, causing integer underflow.

### Root Cause

In `AlignerzVesting.sol:989`, the `getClaimableAmountAndSeconds()` function calculates `secondsPassed = block.timestamp - vestingStartTime` in the else branch without checking if the current time is before the vesting start time, causing arithmetic underflow for future-dated vesting schedules.

### Internal Pre-conditions

1. User needs to have a TVS allocation with `vestingStartTime > block.timestamp` (vesting starts in the future)
2. User or any contract needs to call `getClaimableAmountAndSeconds()` or `claimTokens()` before vesting has started
3. This is common when bidding closes immediately but vesting starts after a delay (e.g., bidding Day 0, vesting starts Day 30)

### External Pre-conditions

None required - this is a logic error affecting any future-dated vesting.

### Attack Path

This is a vulnerability path affecting users with future-dated vesting:

1. **User wins a bid on Day 0** and receives TVS NFT
2. **Vesting is configured to start on Day 30** (common pattern for token generation events)
3. **On Day 15, user checks claimable amount** via frontend or contract query
4. **Frontend calls `getClaimableAmountAndSeconds(allocation, 0)`**
5. **Function calculates `block.timestamp - vestingStartTime`** where current < start
6. **Integer underflow occurs**, transaction reverts
7. **User sees confusing error** instead of "vesting hasn't started yet"
8. **User cannot interact with protocol** until vesting actually starts

### Impact

Users with future-dated vesting cannot:
- Query their claimable amounts before vesting starts
- Interact with any frontend that calls these view functions
- Use any contract integrations that check vesting status

This breaks the user experience for a common pattern (delayed vesting starts) and produces confusing errors instead of clear messaging. While it doesn't cause fund loss, it represents a design limitation that prevents legitimate queries.

### PoC

```solidity
// Setup: Vesting starts 30 days in future
allocation.vestingStartTimes[0] = block.timestamp + 30 days;
allocation.amounts[0] = 1000 ether;
allocation.vestingPeriods[0] = 90 days;

// User tries to check claimable amount
try vesting.getClaimableAmountAndSeconds(allocation, 0) {
    // Never reaches here
} catch {
    // Reverts with arithmetic underflow
}

// Expected: Should return (0, 0) to indicate vesting hasn't started
```

### Mitigation

Add check for future-dated vesting at the start of the function:

```solidity
function getClaimableAmountAndSeconds(Allocation memory allocation, uint256 flowIndex) 
    public view returns(uint256 claimableAmount, uint256 claimableSeconds) {
    uint256 secondsPassed;
    uint256 claimedSeconds = allocation.claimedSeconds[flowIndex];
    uint256 vestingPeriod = allocation.vestingPeriods[flowIndex];
    uint256 vestingStartTime = allocation.vestingStartTimes[flowIndex];
    uint256 amount = allocation.amounts[flowIndex];
    
    // Handle future-dated vesting - FIX
    if (block.timestamp < vestingStartTime) {
        return (0, 0); // Vesting hasn't started yet
    }
    
    if (block.timestamp > vestingPeriod + vestingStartTime) {
        secondsPassed = vestingPeriod;
    } else {
        secondsPassed = block.timestamp - vestingStartTime; // Safe now
    }

    claimableSeconds = secondsPassed - claimedSeconds;
    claimableAmount = (amount * claimableSeconds) / vestingPeriod;
    require(claimableAmount > 0, No_Claimable_Tokens());
    return (claimableAmount, claimableSeconds);
}
```
  