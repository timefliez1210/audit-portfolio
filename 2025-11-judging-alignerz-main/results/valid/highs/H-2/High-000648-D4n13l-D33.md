# [000648] Issues in `calculateFeeAndNewAmountForOneTVS()` leads to DOS in Merge/Split
  
  ### Summary

The fee calculation helper will revert, breaking merge/split operations.

### Root Cause

In `FeesManager.sol:calculateFeeAndNewAmountForOneTVS()` ([lines ~169â€“177](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169C5-L175C1)), there are two defects:

1. Output array `newAmounts` is not allocated with `new uint256[](length)` - writes revert

2. Loop increment is missing - causes infinite loop

### Internal Pre-conditions

1. Caller needs to invoke a merge or split operation that uses this helper

### External Pre-conditions

_No response_

### Attack Path

1. User calls `mergeTVS()` or `splitTVS()`

2. Internal code calls `calculateFeeAndNewAmountForOneTVS()` to compute fees

3. Function attempts to write to unallocated `newAmounts` array 

### Impact

The user cannot split or merge NFTs; core protocol functionality is broken. The protocol suffers complete failure of merge/split features.

### PoC

```solidity
function test_PoC_fee_function_reverts_and_bad_math() public {
        uint256 feeRate = 500; // 5%
        uint256[] memory amount = new uint256[](2);
        amount[0] = 1000 ether;
        amount[1] = 500 ether;

        // Current implementation is broken: expect revert when called
        vm.expectRevert();
        vesting.calculateFeeAndNewAmountForOneTVS(feeRate, amount, 2);

        // Also test bounds: length > amounts.length should revert
        vm.expectRevert();
        vesting.calculateFeeAndNewAmountForOneTVS(feeRate, amount, 3);
    }
```


### Mitigation

```solidity

function calculateFeeAndNewAmountForOneTVS(```solidity

    uint256 feeRate, 

    uint256[] memory amounts, function distributeRewardTVS(uint256 rewardProjectId, address[] calldata kol) ```solidity

    uint256 length

) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {   

    newAmounts = new uint256[](length);   

    for (uint256 i = 0; i < length;) {

        uint256 perFee = calculateFeeAmount(feeRate, amounts[i]);   

        newAmounts[i] = amounts[i] - perFee;

        feeAmount += perFee;  

        unchecked { ++i; }

    }   

    return (feeAmount, newAmounts);
  