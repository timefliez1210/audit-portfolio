# [000414] Remaining distribution helpers revert when no recipients remain
  
  Both remaining-distribution helpers set `uint256 i = len - 1;` before any bounds check (https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L554-L595). 

When `kolTVSAddresses`/`kolStablecoinAddresses` is empty (e.g., everyone claimed already, or the project was configured with zero recipients), `len` is 0 and the subtraction reverts with arithmetic underflow before the loop condition runs. The functions can no longer be called as harmless no-ops and instead panic.

Thereâ€™s no guard elsewhere that guarantees len > 0 when these are invoked, and the arrays are explicitly emptied by normal claims (`_claimRewardTVS`, `_claimStablecoinAllocation`). So a legitimate post-deadline cleanup call will revert whenever nothing remains

## Impact
I'd rate the impact as low as no funds at risk. The bug just makes the cleanup helper revert when nothing remains to distribute, causing minor availability nuisance.

The likelihood is medium as it happens deterministically whenever the owner calls either remaining distribution after the arrays are emptied (common post-claim path).

With that i'd rate the severity a Low 

## POC

```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/Upgrades.sol";
import {Options} from "openzeppelin-foundry-upgrades/Options.sol";
import {Aligners26} from "../src/contracts/token/Aligners26.sol";
import {AlignerzNFT} from "../src/contracts/nft/AlignerzNFT.sol";
import {MockUSD} from "../src/MockUSD.sol";
import {AlignerzVesting} from "../src/contracts/vesting/AlignerzVesting.sol";

// PoC: remaining distribution helpers revert when no recipients remain because the loop initializes with len - 1.
contract AlignerzRemainingDistributionPoC is Test {
    AlignerzVesting private vesting;
    Aligners26 private token;
    MockUSD private usdt;
    AlignerzNFT private nft;

    function setUp() public {
        token = new Aligners26("26Aligners", "A26Z");
        usdt = new MockUSD();
        nft = new AlignerzNFT("AlignerzNFT", "AZNFT", "https://nft.alignerz.bid/");

        Options memory opts;
        opts.unsafeSkipAllChecks = true;

        address payable proxy = payable(
            Upgrades.deployUUPSProxy(
                "AlignerzVesting.sol", abi.encodeCall(AlignerzVesting.initialize, (address(nft))), opts
            )
        );
        vesting = AlignerzVesting(proxy);

        nft.addMinter(proxy);
    }

    function test_distributeRemainingRewardTVS_RevertsWhenNoRecipients() public {
        uint256 startTime = block.timestamp;
        uint256 claimWindow = 1 days;

        vesting.launchRewardProject(address(token), address(usdt), startTime, claimWindow);
        vesting.setTVSAllocation(0, 0, 30 days, new address[](0), new uint256[](0));

        vm.warp(startTime + claimWindow + 1);

        vm.expectRevert(stdError.arithmeticError);
        vesting.distributeRemainingRewardTVS(0);
    }

    function test_distributeRemainingStablecoin_RevertsWhenNoRecipients() public {
        uint256 startTime = block.timestamp;
        uint256 claimWindow = 1 days;

        vesting.launchRewardProject(address(token), address(usdt), startTime, claimWindow);
        vesting.setStablecoinAllocation(0, 0, new address[](0), new uint256[](0));

        vm.warp(startTime + claimWindow + 1);

        vm.expectRevert(stdError.arithmeticError);
        vesting.distributeRemainingStablecoinAllocation(0);
    }
}

```

## Recommendation
Fix would be to handle the empty case (early return) or iterate with `for (uint256 i = len; i > 0; ) { ...; unchecked { --i; } }`
  