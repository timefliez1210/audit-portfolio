# [001033] Uninitialized Memory Array in Fee Calculation Causes Complete Denial of Service for Split and Merge Operations
  
  ### Summary

Uninitialized dynamic memory array in the `calculateFeeAndNewAmountForOneTVS` function will cause complete denial of service for all TVS split and merge operations for all users as any user attempting to split or merge their vesting positions will trigger an out-of-bounds array access that reverts every transaction, rendering two core features advertised in the whitepaper completely unusable.

### Root Cause

In `FeesManager.sol` within the `calculateFeeAndNewAmountForOneTVS` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169-L174), the return variable `uint256[] memory newAmounts` is declared but never initialized before being used in indexed assignments. In Solidity, when a dynamic array is declared as a memory variable in the returns clause without explicit initialization, it defaults to a zero-length array. The function immediately attempts to perform indexed assignments using `newAmounts[i] = amounts[i] - feeAmount` within a loop, but since the array has length zero, accessing any index causes Solidity to revert with panic code 0x32 (array out-of-bounds access). This occurs on the very first iteration regardless of the input parameters, making the function completely unusable in all scenarios including the single flow case.

### Internal Pre-conditions

1. User needs to own at least one TVS NFT representing a vesting position to be eligible to call split or merge functions.
2. The TVS NFT must have at least one vesting flow (nbOfFlows greater than or equal to 1) for the fee calculation function to execute its loop.
3. Owner needs to have set non-zero splitFeeRate or mergeFeeRate values for the fee calculation to be invoked during split or merge operations.

### External Pre-conditions

None. 

### Attack Path

1. User owns TVS NFT with tokenId 1 representing a vesting position containing 1,000,000 A26Z tokens vesting over 90 days with a single flow.
2. User decides to split their position into two parts (70% and 30%) to gain partial liquidity and calls `splitTVS(projectId, [7000, 3000], 1)`.
3. The `splitTVS` function executes and retrieves the amounts array from the allocation storage, then calls `calculateFeeAndNewAmountForOneTVS(splitFeeRate, amounts, nbOfFlows)` to calculate fees and new amounts after fee deduction.
4. Inside `calculateFeeAndNewAmountForOneTVS`, the function declares `uint256[] memory newAmounts` as a return variable but never initializes it with new `uint256[](length)`, leaving it as a zero-length array.
5. The function enters the for loop with `i = 0` and `length = 1`, then immediately attempts to execute `newAmounts[0] = amounts[0] - feeAmount`.
6. Solidity detects an attempt to access index 0 of a zero-length array and reverts the entire transaction with panic code 0x32 (array out-of-bounds access).
7. The transaction reverts and the user receives no split NFTs, with their TVS remaining unsplit and the split feature completely non-functional.
8. The same issue occurs for any user attempting to call `mergeTVS` because it also calls the same broken `calculateFeeAndNewAmountForOneTVS` function at the beginning of its execution to calculate fees on the base merged TVS position.
9. User cannot retry with different parameters, different NFTs, or different split percentages because the bug exists in the fundamental array initialization logic that executes before any actual fee calculation occurs.

### Impact

All TVS holders cannot execute split or merge functionality that is explicitly advertised in the AlignerZ whitepaper sections 4.2 and 4.2.3 as core features enabling liquidity management and flexibility. Users who need to access partial value from their vesting positions (such as the whitepaper example of a user with a 100,000 USD TVS needing 10,000 USD of liquidity through splitting) cannot utilize this functionality at all. The protocol completely fails to deliver on its fundamental value proposition of providing flexible liquidity options through splittable and mergeable vesting positions. The commented-out test line in AlignerzVestingProtocolTest.t.sol where splitTVS call is disabled proves that developers encountered this exact revert during testing but chose to comment out the test and deploy the broken code to testnets without fixing the underlying initialization bug. The whitepaper section 4.2 explicitly states that TVSs are splitable and mergeable offering investors more flexibility, and section 4.2.3 provides detailed examples with fee calculations, all of which are rendered completely meaningless because the underlying operations always revert before any fee logic executes.

### PoC

Nil

### Mitigation

Initialize the dynamic memory array `newAmounts` at the beginning of the `calculateFeeAndNewAmountForOneTVS` function in `FeesManager.sol` by adding `newAmounts = new uint256[](length);` as the first statement before the for loop. This allocates memory for an array of the correct length, allowing indexed assignments to succeed. The complete corrected function should declare the array in the returns clause as currently implemented, then immediately initialize it with `newAmounts = new uint256[](length);` before entering the loop that performs indexed assignments. This ensures the array has the proper length allocated in memory before any access attempts occur, allowing the fee calculation logic to execute without reverting. Additionally, uncomment and properly implement the test case in AlignerzVestingProtocolTest.t.sol to ensure split functionality works correctly across various scenarios including single-flow and multi-flow TVS positions with different split percentages. The initialization must happen before any loop iterations to prevent the out-of-bounds access that currently makes the function completely unusable.
  