# [000746] [High - ðŸ”´] In the Contract `A26ZDividendDistributor.sol` function `getUnclaimedAmounts(..)` `continue`  leads to the infinite loop leads to DoS vulnerability and Freeze the DistributorDividends Contract 
  
  ### Summary

In the Contract `A26ZDividendDistributor.sol` function `getUnclaimedAmounts(..)` `continue`  leads to the infinite loop. 

If one time `continue` hits lead to infinite loop because it skips increament of the `for loop` . It possible easily if the `nftId` is not claimed. So `claimedSeconds[i] == 0` easily zero first increase the `amount += amounts[i]` then hits the continue. This is where infinite loop start 

Because because the increament never be called after the `continue`

```solidity
unchecked {
                ++i;
            }
```
This is never be called in the function . Repeating the same `i` in the function.

In this Contract at many time :
```solidity
/// @notice Internal logic that allows the owner to set crucial amounts for dividends calculations
    function _setAmounts() internal {
        stablecoinAmountToDistribute = stablecoin.balanceOf(address(this));
@>        totalUnclaimedAmounts = getTotalUnclaimedAmounts();
        emit amountsSet(stablecoinAmountToDistribute, totalUnclaimedAmounts);
    }
```

```solidity
/// @notice USD value in 1e18 of all the unclaimed tokens of all the TVS
    function getTotalUnclaimedAmounts() public returns (uint256 _totalUnclaimedAmounts) {
        uint256 len = nft.getTotalMinted();
        for (uint i; i < len;) {
            (, bool isOwned) = safeOwnerOf(i);
@>            if (isOwned) _totalUnclaimedAmounts += getUnclaimedAmounts(i);
            unchecked {
                ++i;
            }
        }
    }
```

### Root Cause

The issue is the improper use of the `continue` in the function 
```solidity
 /// @notice USD value in 1e18 of all the unclaimed tokens of a TVS
    /// @param nftId NFT Id
    function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
        if (address(token) == address(vesting.allocationOf(nftId).token)) return 0;
        uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
        uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
        uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
        bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
        uint256 len = vesting.allocationOf(nftId).amounts.length;
        for (uint i; i < len;) {
@>            if (claimedFlows[i]) continue;
@>           if (claimedSeconds[i] == 0) {
                amount += amounts[i];
                continue;
            }
            uint256 claimedAmount = claimedSeconds[i] * amounts[i] / vestingPeriods[i];
            uint256 unclaimedAmount = amounts[i] - claimedAmount;
            amount += unclaimedAmount;
            unchecked {
                ++i;
            }
        }
        unclaimedAmountsIn[nftId] = amount;
    }
```

### Internal Pre-conditions

There is should be one condition where `claimedFlows[i] == true` or `claimedSeconds[i] == 0` this lead to infinite loop in the function 

### External Pre-conditions

None

### Attack Path

Attacker or User(Bidder) never claimSeconds in One of their Allocation so `claimedSeconds[i] == 0` or Completely claimed the flow `claimedFlows[i] == true`

### Impact

Due to this the protocol never recover `DoS` vulnerability becuase of `out of gas ` infinite Loop 

### PoC

PoC from User(Attacker/ Bidder):
1. Call the `claimRewardTVS(..)` function 
```solidity
function claimRewardTVS(uint256 rewardProjectId) external {
        RewardProject storage rewardProject = rewardProjects[rewardProjectId];
        require(block.timestamp < rewardProject.claimDeadline, Deadline_Has_Passed());
        address kol = msg.sender;
        _claimRewardTVS(rewardProjectId, kol);
    }
```

then the `_claimRewardTVS(rewardProjectId, kol)` is called in the  function 

```solidity
    /// @notice Internal logic of reward TVS claim
    /// @param rewardProjectId Id of the rewardProject
    /// @param kol address of the KOL who chose to be rewarded in TVS
    function _claimRewardTVS(uint256 rewardProjectId, address kol) internal {
        RewardProject storage rewardProject = rewardProjects[rewardProjectId];
        uint256 amount = rewardProject.kolTVSRewards[kol];
        require(amount > 0, Caller_Has_No_TVS_Allocation());
        rewardProject.kolTVSRewards[kol] = 0;
        uint256 nftId = nftContract.mint(kol);
        rewardProject.allocations[nftId].amounts.push(amount);
        // ..
@>        rewardProject.allocations[nftId].claimedSeconds.push(0);
        // ..
    }
```

2. Here the `claimedSeconds` is push as the zero then in the Distributor this `NftId` is called when `_setAmounts()` function 

```solidity
function _setAmounts() internal {
        stablecoinAmountToDistribute = stablecoin.balanceOf(address(this));
@>        totalUnclaimedAmounts = getTotalUnclaimedAmounts();
        emit amountsSet(stablecoinAmountToDistribute, totalUnclaimedAmounts);
    }

```

```solidity
/// @notice USD value in 1e18 of all the unclaimed tokens of all the TVS
    function getTotalUnclaimedAmounts() public returns (uint256 _totalUnclaimedAmounts) {
        uint256 len = nft.getTotalMinted(); // Here we goes to all nft minted in by the Protocol
        for (uint i; i < len;) {
            (, bool isOwned) = safeOwnerOf(i);
 @>           if (isOwned) _totalUnclaimedAmounts += getUnclaimedAmounts(i);
            unchecked {
                ++i;
            }
        }
    }

    /// @notice USD value in 1e18 of all the unclaimed tokens of a TVS
    /// @param nftId NFT Id
@>    function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
        /// .. 
        for (uint i; i < len;) {
            if (claimedFlows[i]) continue;
            if (claimedSeconds[i] == 0) {
                amount += amounts[i];
                continue;
            }
            // ..
            // If the Continue is hits the increament never increased lead to infinite loops
            unchecked {
                ++i;
            }
        }
        unclaimedAmountsIn[nftId] = amount;
    }
```

### Mitigation

_No response_
  