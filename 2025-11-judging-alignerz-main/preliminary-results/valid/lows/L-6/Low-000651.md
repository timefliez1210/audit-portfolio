# [000651] Loop Bounds Mismatch in `distributeRewardTVS() will lead to transaction revert
  
  ### Summary

KOL reward distribution will revert  as the function uses internal array length as loop bound but indexes into caller-provided array without validation.

### Root Cause

In `AlignerzVesting.sol:distributeRewardTVS()` ([lines ~486â€“497](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L525C1-L535C6)), the loop iterates using `rewardProject.kolTVSAddresses.length` but indexes into the external parameter `kol[]` array without verifying lengths match.

### Internal Pre-conditions

1. Owner needs to have called `launchRewardProject()` to create a reward project4. 

2. Owner needs to have called `setTVSAllocation()` to populate `kolTVSAddresses`

3. `block.timestamp > rewardProject.claimDeadline` must be true- Funds are permanently locked in the contract

### External Pre-conditions

1. Caller provides a `kol[]` array of shorter length than internal `kolTVSAddresses.length`

### Attack Path

1. Owner launches reward project with 5 KOLs in internal storage**PoC**:```solidity

2. Owner calls `distributeRewardTVS(projectId, [kol1, kol2, kol3])` with only 3 addresses (array too short)

3. Loop executes with `i < 5` but tries to access `kol[4]` which does not exist```solidity// User owns NFT #100 with 1000 tokens allocated

4. Transaction reverts with out-of-bounds error

### Impact

The KOLs cannot receive their distributed rewards. The protocol suffers a denial of service; distribution fails.

### PoC

```solidity
function test_PoC_distributeRewardTVS_oob_revert() public {
        // Launch reward project and allocate to two KOLs
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);

        address[] memory kols = new address[](2);
        kols[0] = address(0x1111);
        kols[1] = address(0x2222);
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 50 ether;
        amounts[1] = 50 ether;

        vm.prank(projectCreator);
        vesting.setTVSAllocation(0, 100 ether, 30 days, kols, amounts);

        // Now call distributeRewardTVS with a shorter array (length 1) which should cause an out-of-bounds access
        address[] memory supplied = new address[](1);
        supplied[0] = kols[0];

        vm.prank(projectCreator);
        vm.expectRevert();
        vesting.distributeRewardTVS(0, supplied);
    }
```

### Mitigation

```solidity

function distributeRewardTVS(uint256 rewardProjectId, address[] calldata kol) 

    external onlyOwner {

    RewardProject storage rewardProject = rewardProjects[rewardProjectId];

    require(block.timestamp > rewardProject.claimDeadline, Deadline_Has_Not_Passed());

    uint256 len = kol.length;

    for (uint256 i; i < len;) {

        require(rewardProject.kolTVSRewards[kol[i]] > 0, "No_Allocation");**Mitigation**:

        _claimRewardTVS(rewardProjectId, kol[i]);

        unchecked { ++i; }```solidity**Recommendation**:

    }

}
  