# [000668] Unbounded loop allows DoS of `_setDividends()`.
  
  ### Summary

The use of an unbounded `for` loop based directly on `nft.getTotalMinted()` causes a Denial of Service when the total minted supply grows.
As a result, `_setDividends()` can become permanently unusable.

### Root Cause

https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol#L215
In `_setDividends()` the protocol iterates over:
```solidity
uint256 len = nft.getTotalMinted();
for (uint256 i; i < len; ) { ... }
```
There isn't any upper bound, batching, or gas-safe mechanism.
This design is unsafe because:
- `len` can grow arbitrarily large as more NFTs are minted
- Gas grows linearly with `len`
  
Thus, the function becomes non-scalable and can be pushed into permanent revert as soon as len exceeds the gas limit.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. Attacker mints NFTs repeatedly by placing small bids and claimingNFT, increasing `nft.getTotalMinted()`.
2. When `getTotalMinted()`becomes high enough, calling `_setDividends()` causes gas exhaustion. 

### Impact

The protocol can't set the dividends.
The users can't claim their dividends.

### PoC

_No response_

### Mitigation

Use batch processing : 
Instead of iterating over all minted NFTs in a single call, the function should process them in fixed-size batches (like 50 or 100 IDs per call).
This avoids gas exhaustion and prevents the function from reverting as the total minted supply increases.

A typical approach is:
- Call the function once for IDs 0 → 99
- Then again for 100 → 199
- Then 200 → 299, and so on
  