# [000886] Incorrect Fee Deduction Logic in calculateFeeAndNewAmountForOneTVS
  
  ### Summary

The function calculateFeeAndNewAmountForOneTVS is intended to compute:

The fee applicable to each amount in the amounts array

The new amount after subtracting the individual fee

However, the implementation mistakenly uses the cumulative feeAmount when computing each element of newAmounts. This leads to incorrect newAmounts being calculated and may result in over-deductions or unexpected outputs.

### Root Cause

https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169

```sol
function calculateFeeAndNewAmountForOneTVS(
    uint256 feeRate, 
    uint256[] memory amounts, 
    uint256 length
) 
    public 
    pure 
    returns (uint256 feeAmount, uint256[] memory newAmounts) 
{
    for (uint256 i; i < length;) {
        feeAmount += calculateFeeAmount(feeRate, amounts[i]);
        newAmounts[i] = amounts[i] - feeAmount;
    }
}
```

Because feeAmount is incremented during each iteration:

At i = 0, newAmounts[0] subtracts the fee for the first element → correct.

At i = 1, newAmounts[1] subtracts the fee for element 0 plus the fee for element 1 → incorrect.

At i = n, newAmounts[n] subtracts all previous fees cumulatively → very incorrect.

### Internal Pre-conditions

None

### External Pre-conditions

None

### Attack Path

None

### Impact

Users receiving incorrect post-fee amounts

Funds being over-withheld, potentially causing loss of funds

### PoC

None

### Mitigation

Update the function so that each new amount is calculated by subtracting only its own individual fee, not the cumulative sum.
  