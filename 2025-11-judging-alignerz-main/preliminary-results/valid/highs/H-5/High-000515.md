# [000515] Cumulative Fee Aggregation Bug Leads to Users Lose Extra Tokens Beyond Intended Fees
  
  ### Summary

The `calculateFeeAndNewAmountForOneTVS()` function incorrectly subtracts a cumulative running total of fees from each flow instead of subtracting only that flow's individual fee. This causes later flows to lose significantly more tokens than intended.


### Root Cause


In `FeesManager.sol` in `calculateFeeAndNewAmountForOneTVS()` function incorrectly subtracts a cumulative running total of fees from each flow instead of subtracting only that flow's individual fee.

```solidity
function calculateFeeAndNewAmountForOneTVS(uint256 feeRate, uint256[] memory amounts, uint256 length) 
    public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
    for (uint256 i; i < length;) {
        feeAmount += calculateFeeAmount(feeRate, amounts[i]); // ← Accumulates total
@>      newAmounts[i] = amounts[i] - feeAmount; // ← BUG: Subtracts CUMULATIVE total
    }
}
```

Code snippet- 
https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169-L172


### Internal Pre-conditions

1. User calls `mergeTVS()` or `splitTVS()` with multiple allocation (≥2).
2. Fee rate is non-zero (`splitFeeRate` or `mergeFeeRate` > 0).
 


### External Pre-conditions

N/A

### Attack Path


1. Setup:
- NFT has 3 vesting flows: `amounts = [100, 100, 100]` (300 total)
- Fee rate: 1% (100 basis points)
- Expected fee per flow: 1 token each = 3 total

2. Execution Flow:

User calls: `mergeTVS(projectId, nftId, [], [])`
    ↓
`calculateFeeAndNewAmountForOneTVS(100, [100,100,100], 3)`
    ↓
Loop iteration:
    i=0: fee = 1, feeAmount = 1  → newAmounts[0] = 100 - 1 = 99  ->right
    i=1: fee = 1, feeAmount = 2  → newAmounts[1] = 100 - 2 = 98  ->wrong
    i=2: fee = 1, feeAmount = 3  → newAmounts[2] = 100 - 3 = 97  ->wrong
    
Returns: feeAmount = 3, newAmounts = [99, 98, 97]
    ↓
`mergedTVS.amounts` = [99, 98, 97] (stored permanently)
    ↓
`token.safeTransfer(treasury, 3)` (treasury gets 3 tokens)

3. Result:
- Original total: 300 tokens
- New total: 99 + 98 + 97 = 294 tokens
- Treasury received: 3 tokens
- User lost: 300 - 294 = 6 tokens
- Unaccounted loss: 6 - 3 = 3 tokens (though `withdrawStuckTokens()` can handle this but user paying more fees)


### Impact

Users lose extra tokens beyond intended fees during call `splitTVS()` and `mergeTVS()`.

### PoC

N/A

### Mitigation

N/A
  