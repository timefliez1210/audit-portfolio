# [001034] [High] Compounding Fee Calculation Logic Causes Systematic Overcharging in TVS Split and Merge Operations
  
  ### Summary

Incorrect fee accumulation logic in the `calculateFeeAndNewAmountForOneTVS` function will cause systematic and exponentially increasing overcharging for all users performing split or merge operations on multi-flow TVS positions as the function uses accumulated total fees instead of individual per-flow fees when calculating fee-adjusted amounts, resulting in users losing up to 55% or more of their tokens compared to the advertised 1% fee rate when operating on positions with multiple vesting flows.


### Root Cause

In `FeesManager.sol` within the `calculateFeeAndNewAmountForOneTVS` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169-L181), the variable `feeAmount` serves dual purposes as both an accumulator for the total fee across all flows and as the value subtracted from each individual flow amount. The loop logic first accumulates fees using `feeAmount += calculateFeeAmount(feeRate, amounts[i])` to sum the total fee, then immediately uses this accumulated total in the assignment `newAmounts[i] = amounts[i] - feeAmount` to calculate the fee-adjusted amount for the current flow. This means the first flow is correctly charged its individual fee, but the second flow is charged the sum of the first and second flow fees, the third flow is charged the sum of the first three flow fees, and so on, creating a compounding overcharge that increases quadratically with the number of flows. The correct implementation should calculate each flow's individual fee using a local variable, accumulate the total separately, and subtract only the individual fee from each flow's amount.

### Internal Pre-conditions

1. User needs to own a TVS NFT with multiple vesting flows (nbOfFlows must be at least 2) for the compounding effect to manifest, as single-flow positions are charged correctly by coincidence.
2. Owner needs to have set splitFeeRate or mergeFeeRate to a non-zero value (typically 50 basis points for 0.5% or 100 basis points for 1%) for fees to be calculated and the bug to cause financial impact.
3. The uninitialized array bug in the same function must be fixed (newAmounts must be initialized with proper length) for this compounding bug to become active and cause actual fund loss.

### External Pre-conditions

None. This vulnerability exists purely within the mathematical logic of fee calculation and does not depend on external protocol states, oracle prices, market conditions, token prices, gas prices, or any third-party integrations. Once the uninitialized array bug is fixed, this compounding bug will immediately begin causing systematic overcharging on every split and merge operation involving multi-flow TVS positions.

### Attack Path

1. User owns TVS NFT with tokenId 1 containing three vesting flows of 1,000 tokens each (total 3,000 tokens) with a 1% split fee rate (100 basis points) configured by the owner.
2. User calls `splitTVS(projectId, [5000, 5000], 1)` to split their position into two equal parts.
3. The `splitTVS` function calls `calculateFeeAndNewAmountForOneTVS(100, [1000, 1000, 1000], 3)` to calculate fees assuming the uninitialized array bug has been fixed.
4. In the first loop iteration with i equals 0, the function calculates `feeAmount = 0 + (1000 * 100 / 10000) = 10`, then assigns `newAmounts[0] = 1000 - 10 = 990` which is correct.
5. In the second loop iteration with i equals 1, the function calculates `feeAmount = 10 + (1000 * 100 / 10000) = 20`, then assigns `newAmounts[1] = 1000 - 20 = 980` which is incorrect as it should be 990.
6. In the third loop iteration with i equals 2, the function calculates `feeAmount = 20 + (1000 * 100 / 10000) = 30`, then assigns `newAmounts[2] = 1000 - 30 = 970` which is incorrect as it should be 990.
7. The function returns newAmounts as [990, 980, 970] with total 2,940 tokens instead of the correct [990, 990, 990] with total 2,970 tokens.
8. User loses 30 additional tokens beyond the legitimate 30 token fee, representing a 1% overcharge on top of the 1% fee for a total 2% deduction instead of 1%.
9. The overcharging scales quadratically with more flows: with 10 flows of 1,000 tokens each and 1% fee, user expects total 9,900 tokens (100 fee) but receives only 9,450 tokens (550 total deducted), losing an extra 450 tokens representing 4.5% overcharge on top of the 1% legitimate fee.
10. With 20 flows, the user loses approximately 19% extra on top of the 1% fee, and the loss percentage continues increasing quadratically as the number of flows increases.

### Impact

All users performing split or merge operations on TVS positions containing multiple vesting flows suffer systematic and increasing overcharges that scale quadratically with the number of flows in their position. For a position with N flows and fee rate F, users lose an extra F times N times (N minus 1) divided by 2 percentage points beyond the legitimate fee. With 10 flows and 1% fee, users lose 4.5% extra (total 5.5% deduction instead of 1%). With 20 flows and 1% fee, users lose 19% extra (total 20% deduction instead of 1%). The whitepaper section 4.2.3 provides an example of splitting 1,200 A26Z tokens with 0.5% fee expecting 6 tokens deducted, but if this position had 3 flows of 400 tokens each, the user would actually lose 8 tokens (expected 1,194 remaining but actual 1,192 remaining). These overcharged tokens are transferred to the treasury as fees, representing direct theft from users that benefits the protocol at user expense. The bug violates the whitepaper's explicit promise of specific fee percentages and creates an unfair system where users with multi-flow positions (which may arise from multiple token claims, merges, or bidding pool allocations) are punished with exponentially higher effective fees compared to users with single-flow positions who pay the correct advertised rate.

### PoC

Add test to test/CompoundingFeeCalculationBugProofTest.t.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";

contract CompoundingFeeCalculationBugProof is Test {
    
    uint256 constant BASIS_POINT = 10_000;
    
    function calculateFeeAmount(uint256 feeRate, uint256 amount) public pure returns(uint256 feeAmount) {
        feeAmount = amount * feeRate / BASIS_POINT;
    }
    
    function calculateFeeAndNewAmountForOneTVS_BUGGY(
        uint256 feeRate, 
        uint256[] memory amounts, 
        uint256 length
    ) public view returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length);
        
        for (uint256 i; i < length;) {
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;  // ← BUG: Uses accumulated total
            unchecked { ++i; }
        }
    }
    
    function calculateFeeAndNewAmountForOneTVS_FIXED(
        uint256 feeRate, 
        uint256[] memory amounts, 
        uint256 length
    ) public view returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length);
        
        for (uint256 i; i < length;) {
            uint256 individualFee = calculateFeeAmount(feeRate, amounts[i]);  // ← Local variable
            feeAmount += individualFee;
            newAmounts[i] = amounts[i] - individualFee;  // ← Uses individual fee
            unchecked { ++i; }
        }
    }
    
    function testCompoundingBug_ThreeFlows() public view {
        console.log("\n=== PROOF: Compounding Fee Bug with 3 Flows ===\n");
        
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1000;
        amounts[1] = 1000;
        amounts[2] = 1000;
        
        console.log("Input: [1000, 1000, 1000]");
        console.log("Fee rate: 1% (100 basis points)");
        console.log("Total input: 3000 tokens\n");
        
        (uint256 totalFeeBuggy, uint256[] memory newAmountsBuggy) = 
            calculateFeeAndNewAmountForOneTVS_BUGGY(100, amounts, 3);
        
        console.log("BUGGY Implementation:");
        console.log("- Flow 1:", newAmountsBuggy[0], "(fee: 10)");
        console.log("- Flow 2:", newAmountsBuggy[1], "(fee: 20 accumulated)");
        console.log("- Flow 3:", newAmountsBuggy[2], "(fee: 30 accumulated)");
        console.log("- Total remaining:", newAmountsBuggy[0] + newAmountsBuggy[1] + newAmountsBuggy[2]);
        console.log("- Total fee collected:", totalFeeBuggy);
        
        (uint256 totalFeeFixed, uint256[] memory newAmountsFixed) = 
            calculateFeeAndNewAmountForOneTVS_FIXED(100, amounts, 3);
        
        console.log("\nCORRECT Implementation:");
        console.log("- Flow 1:", newAmountsFixed[0], "(fee: 10)");
        console.log("- Flow 2:", newAmountsFixed[1], "(fee: 10)");
        console.log("- Flow 3:", newAmountsFixed[2], "(fee: 10)");
        console.log("- Total remaining:", newAmountsFixed[0] + newAmountsFixed[1] + newAmountsFixed[2]);
        console.log("- Total fee collected:", totalFeeFixed);
        
        uint256 userLoss = (newAmountsFixed[0] + newAmountsFixed[1] + newAmountsFixed[2]) - 
                           (newAmountsBuggy[0] + newAmountsBuggy[1] + newAmountsBuggy[2]);
        
        console.log("\n=== USER LOSS ===");
        console.log("Expected total: 2970 (3000 - 30 fee)");
        console.log("Actual total:", newAmountsBuggy[0] + newAmountsBuggy[1] + newAmountsBuggy[2]);
        console.log("Overcharged by:", userLoss, "tokens");
        console.log("Percentage overcharge:", (userLoss * 10000) / 3000, "basis points");
    }
    
    function testCompoundingBug_TenFlows() public view {
        console.log("\n=== PROOF: Compounding Bug with 10 Flows ===\n");
        
        uint256[] memory amounts = new uint256[](10);
        for (uint256 i = 0; i < 10; i++) {
            amounts[i] = 1000;
        }
        
        console.log("Input: 10 flows of 1000 each");
        console.log("Total: 10,000 tokens");
        console.log("Fee rate: 1%\n");
        
        (uint256 totalFeeBuggy, uint256[] memory newAmountsBuggy) = 
            calculateFeeAndNewAmountForOneTVS_BUGGY(100, amounts, 10);
        
        uint256 sumBuggy = 0;
        for (uint256 i = 0; i < 10; i++) {
            sumBuggy += newAmountsBuggy[i];
        }
        
        (, uint256[] memory newAmountsFixed) = 
            calculateFeeAndNewAmountForOneTVS_FIXED(100, amounts, 10);
        
        uint256 sumFixed = 0;
        for (uint256 i = 0; i < 10; i++) {
            sumFixed += newAmountsFixed[i];
        }
        
        console.log("BUGGY: User receives", sumBuggy, "tokens");
        console.log("CORRECT: User should receive", sumFixed, "tokens");
        console.log("User loss:", sumFixed - sumBuggy, "tokens");
        console.log("\nExpected fee: 100 tokens (1%)");
        console.log("Actual total deducted:", 10000 - sumBuggy, "tokens");
        console.log("Effective fee rate:", ((10000 - sumBuggy) * 10000) / 10000, "basis points");
        console.log("Should be: 100 basis points (1%)");
        
        uint256 extraLoss = (sumFixed - sumBuggy);
        console.log("\n=== CRITICAL OVERCHARGE ===");
        console.log("Extra loss beyond legitimate fee:", extraLoss, "tokens");
        console.log("Percentage of total:", (extraLoss * 100) / 10000, "%");
    }
    
    function testWhitepaperExample_Affected() public view {
        console.log("\n=== WHITEPAPER EXAMPLE: 1200 A26Z, 0.5% Fee ===\n");
        
        console.log("Scenario: 1200 tokens in 3 flows of 400 each");
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 400e18;
        amounts[1] = 400e18;
        amounts[2] = 400e18;
        
        (uint256 totalFeeBuggy, uint256[] memory newAmountsBuggy) = 
            calculateFeeAndNewAmountForOneTVS_BUGGY(50, amounts, 3);  // 0.5% = 50 basis points
        
        uint256 sumBuggy = (newAmountsBuggy[0] + newAmountsBuggy[1] + newAmountsBuggy[2]) / 1e18;
        
        console.log("Whitepaper states: 1200 - 6 = 1194");
        console.log("With bug, user receives:", sumBuggy, "tokens");
        console.log("Expected: 1194 tokens");
        console.log("Actual loss:", 1194 - sumBuggy, "extra tokens beyond fee");
        
        if (sumBuggy != 1194) {
            console.log("\n!!! WHITEPAPER PROMISE VIOLATED !!!");
        }
    }
}
```

### Mitigation

Modify the `calculateFeeAndNewAmountForOneTVS` function in `FeesManager.sol` to use a local variable for storing each flow's individual fee calculation while maintaining the separate feeAmount accumulator for the total fee across all flows. Replace the line `newAmounts[i] = amounts[i] - feeAmount;` with a two-step process: first calculate `uint256 individualFee = calculateFeeAmount(feeRate, amounts[i]);` using a local variable scoped to the loop iteration, then use this individual fee in two places: accumulate it into the total using feeAmount += individualFee; and subtract only the individual fee from the current flow amount using `newAmounts[i] = amounts[i] - individualFee;`. This ensures each flow is charged exactly its proportional fee based on its individual amount rather than being charged the accumulated sum of all previous fees plus its own fee. The corrected logic maintains the same total fee collection (which is correct) while distributing the fee deductions properly across individual flows according to their respective amounts. After implementing this fix, create comprehensive tests covering single-flow positions, multi-flow positions with varying numbers of flows (3, 5, 10, 20), different fee rates (50 and 100 basis points), and verify that the invariant `sum(newAmounts) + totalFee == sum(amounts)` holds for all test cases while each individual flow is charged exactly `amount * feeRate / BASIS_POINT` fee.
  