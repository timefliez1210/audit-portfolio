# [000413] Off-by-one pool cap lets an 11th vesting pool be created despite a 10-pool limit
  
  https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L675-L695 guards pool creation with `require(biddingProject.poolCount <= 10, Cannot_Exceed_Ten_Pools_Per_Project());`. Because the check happens before poolCount is incremented, a project with `poolCount == 10` still passes, creates `poolId = 10`, and bumps `poolCount` to 11. The revert only triggers on the 12th call. This contradicts the stated limit (“Cannot_Exceed_Ten_Pools_Per_Project”) and there’s no other cap elsewhere.
So the limit of 10 pools is not enforced and an 11th pool can be created

## Impact
I'd rate the severity as Low. The off-by-one in `createPool` only lets the owner create an 11th pool despite a stated cap of 10. Funds aren’t directly at risk and functionality largely continues, so impact is low. Likelihood is high because the owner can trigger it at will.

## POC
```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/Upgrades.sol";
import {Options} from "openzeppelin-foundry-upgrades/Options.sol";
import {Aligners26} from "../src/contracts/token/Aligners26.sol";
import {AlignerzNFT} from "../src/contracts/nft/AlignerzNFT.sol";
import {MockUSD} from "../src/MockUSD.sol";
import {AlignerzVesting} from "../src/contracts/vesting/AlignerzVesting.sol";

// PoC: Off-by-one pool cap allows creating 11 pools despite a 10-pool limit.
contract AlignerzPoolCapOffByOnePoC is Test {
    AlignerzVesting private vesting;
    Aligners26 private token;
    AlignerzNFT private nft;
    MockUSD private usdt;

    function setUp() public {
        usdt = new MockUSD();
        token = new Aligners26("26Aligners", "A26Z");
        nft = new AlignerzNFT("AlignerzNFT", "AZNFT", "https://nft.alignerz.bid/");

        Options memory opts;
        opts.unsafeSkipAllChecks = true;

        address payable proxy = payable(
            Upgrades.deployUUPSProxy(
                "AlignerzVesting.sol",
                abi.encodeCall(AlignerzVesting.initialize, (address(nft))),
                opts
            )
        );
        vesting = AlignerzVesting(proxy);

        nft.addMinter(proxy);
        vesting.setTreasury(address(1));
    }

    function test_OwnerCanCreateElevenPoolsDueToOffByOne() public {
        uint256 projectId = 0;
        uint256 allocation = 1 ether;

        token.approve(address(vesting), type(uint256).max);

        vesting.launchBiddingProject(
            address(token),
            address(usdt),
            block.timestamp,
            block.timestamp + 10 days,
            bytes32(0),
            false
        );

        // 11 pool creations succeed even though the limit is documented as 10.
        for (uint256 i = 0; i < 11; i++) {
            vesting.createPool(projectId, allocation, 1 ether, false);
        }

        (, , , uint256 poolCount, , , , , , ) = vesting.biddingProjects(projectId);
        assertEq(poolCount, 11, "11th pool should not be possible if cap were enforced");

        // The 12th attempt finally reverts because the off-by-one check triggers at >10 after increment.
        vm.expectRevert(AlignerzVesting.Cannot_Exceed_Ten_Pools_Per_Project.selector);
        vesting.createPool(projectId, allocation, 1 ether, false);
    }
}

```

## Recommendation
Fix would be to `require < 10` (or increment first, then `require poolCount <= 10`).
  