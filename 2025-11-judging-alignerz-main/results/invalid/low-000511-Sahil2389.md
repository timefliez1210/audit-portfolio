# [000511] Self-Merge Burns Target NFT and Permanently Freezes Allocation
  
  ### Summary


The contract allows merging an NFT into itself.
When this happens, `_merge()` burns the target NFT, leaving the allocation stored in the contract but with no valid NFT owner.
As a result, `claimTokens()` can never be called, and all tokens inside the allocation become permanently locked.


### Root Cause

In `AlignerzVesting.sol` the `_merge()` functions no check prevents `nftId == mergedNftId`. Storage aliasing occurs: `mergedTVS` and `TVSToMerge` point to the same storage slot.`_merge()` unconditionally burns the NFT, even if it is the target NFT (when user call `mergeTVS()`).

```solidity
//missing check about that
 function _merge(Allocation storage mergedTVS, uint256 projectId, uint256 nftId, IERC20 token) internal returns (uint256 feeAmount) {
        require(msg.sender == nftContract.extOwnerOf(nftId), Caller_Should_Own_The_NFT());
        
        bool isBiddingProjectTVSToMerge = NFTBelongsToBiddingProject[nftId];
        (Allocation storage TVSToMerge, IERC20 tokenToMerge) = isBiddingProjectTVSToMerge ?
        (biddingProjects[projectId].allocations[nftId], biddingProjects[projectId].token) :
        (rewardProjects[projectId].allocations[nftId], rewardProjects[projectId].token);
        require(address(token) == address(tokenToMerge), Different_Tokens());

        uint256 nbOfFlowsTVSToMerge = TVSToMerge.amounts.length;
        for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
            uint256 fee = calculateFeeAmount(mergeFeeRate, TVSToMerge.amounts[j]);
            mergedTVS.amounts.push(TVSToMerge.amounts[j] - fee);
            mergedTVS.vestingPeriods.push(TVSToMerge.vestingPeriods[j]);
            mergedTVS.vestingStartTimes.push(TVSToMerge.vestingStartTimes[j]);
            mergedTVS.claimedSeconds.push(TVSToMerge.claimedSeconds[j]);
            mergedTVS.claimedFlows.push(TVSToMerge.claimedFlows[j]);
            feeAmount += fee;
        }
        nftContract.burn(nftId);
    }
```
Code snippet-
https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1028-L1048


### Internal Pre-conditions

1. `mergeTVS()` loads `mergedTVS` as a storage reference.
2. Passing the same ID means `_merge()` operates on the same storage struct.


### External Pre-conditions

2. User includes `mergedNftId` inside the `nftIds[]` list.


### Attack Path


1. Caller owns NFT `X`.
2. Caller calls:

   ```solidity
   mergeTVS(projectId, X, [projectId], [X])
   ```
3. Inside `_merge()`:

   * `TVSToMerge` resolves to the same allocation as `mergedTVS`.
   * `_merge()` calls:

     ```solidity
     nftContract.burn(X)
     ```
4. NFT `X` is burned.
5. `claimTokens(X, …)` can never succeed because burned NFTs have no owner.



### Impact

 NFT is destroyed. Allocation remains in contract storage. Tokens inside the allocation can never be claimed → permanent loss of user funds (Can happen accidentally or maliciously).


### PoC

N/A

### Mitigation

N/A
  