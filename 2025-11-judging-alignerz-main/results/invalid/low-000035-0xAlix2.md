# [000035] Merged NFT can be accidentally burned during merge
  
  ### Summary

In `mergeTVS`, the function does not prevent the caller from passing the `mergedNftId` inside the `nftIds` array:

```solidity
function mergeTVS(
    uint256 projectId,
    uint256 mergedNftId,
    uint256[] calldata projectIds,
    uint256[] calldata nftIds
) external returns (uint256) {
    ...
    uint256 nbOfNFTs = nftIds.length;
    ...
    for (uint256 i; i < nbOfNFTs; i++) {
        feeAmount += _merge(mergedTVS, projectIds[i], nftIds[i], token);
    }
    ...
}
```

```solidity
function _merge(
    Allocation storage mergedTVS,
    uint256 projectId,
    uint256 nftId,
    IERC20 token
) internal returns (uint256 feeAmount) {
    ...
    nftContract.burn(nftId);
}
```

If `mergedNftId` appears in `nftIds`, `_merge` will be called with `nftId == mergedNftId`, and the function will **burn the NFT that is supposed to survive the merge**, while still returning `mergedNftId` from `mergeTVS`.

### Root Cause

Missing validation that `mergedNftId` is not included in the `nftIds` array passed for merging, https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/AlignerzVesting.sol#L1002.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

N/A

### Impact

The “destination” NFT (`mergedNftId`) can be burned during the merge.

### PoC

_No response_

### Mitigation

Consider adding an explicit check to forbid passing the merged NFT inside the list of NFTs to merge:

```solidity
function mergeTVS(
    uint256 projectId,
    uint256 mergedNftId,
    uint256[] calldata projectIds,
    uint256[] calldata nftIds
) external returns (uint256) {
    ...
    uint256 nbOfNFTs = nftIds.length;
    for (uint256 i; i < nbOfNFTs; ) {
        require(nftIds[i] != mergedNftId, Not_Enough_TVS_To_Merge());
        ...
        unchecked { ++i; }
    }
    ...
}
```
  