# [000646] Project ID Mismatch in `_merge()` - Cross-Project Token Contamination
  
  ### Summary

Tokens from different projects will be merged together, corrupting accounting and potentially making funds inaccessible due to token type mismatches. For example nft id 5 from project id 2, if there is a mismatch in the array parsed to mergeTVS() could lead to nftId 5 being used to read from project id 1, which would lead to 0 allocations merged and the nft burned, thereby leading to lose of all TVS allocation assigned to that nft id

### Root Cause

In `AlignerzVesting.sol:mergeTVS()` / `_merge()` ([lines ~1530â€“1570](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1028C4-L1048C6)), there is no validation that each source NFT (`projectIds[i]`) belongs to the same project as the destination (`projectId`), allowing cross-project merges. 

### Internal Pre-conditions

1. User needs to hold NFTs in multiple projects

2. User calls `mergeTVS()` with mismatched `projectIds[]`

### External Pre-conditions

_No response_

### Attack Path

1. User owns NFT #5 in project A,  NFT #10 in project B and NFT #15 in project C

2. User calls `mergeTVS(projectId=A, mergedNftId=5, projectIds=[C,B], nftIds=[10,15])`    

3. `_merge()` retrieves allocation from project B but tries to read for NFT 15 and finds 0 allocations and merges that then burns NFT 15, same applies to NFT10

4. Token types mismatch; allocation data becomes corrupted.

### Impact

The user suffers token contamination and potential loss due to type mismatches. The protocol's accounting becomes inaccurate. 

### PoC

```solidity
function test_PoC_merge_project_id_mismatch_allowed() public {
        // Launch two reward projects
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);
        vm.prank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 1_000);

        address[] memory kols = new address[](1);
        kols[0] = address(this);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 5 ether;

        // Allocate in project 0,1 and 2
        vm.prank(projectCreator);
        vesting.setTVSAllocation(0, 5 ether, 30 days, kols, amounts);
        vm.prank(projectCreator);
        vesting.setTVSAllocation(1, 5 ether, 30 days, kols, amounts);
        vm.prank(projectCreator);
        vesting.setTVSAllocation(2, 5 ether, 30 days, kols, amounts);

        uint256 beforeA = nft.getTotalMinted();
        vm.prank(address(this));
        vesting.claimRewardTVS(0);
        uint256 nftA = beforeA;

        uint256 beforeB = nft.getTotalMinted();
        vm.prank(address(this));
        vesting.claimRewardTVS(1);
        uint256 nftB = beforeB;

        uint256 beforeC = nft.getTotalMinted();
        vm.prank(address(this));
        vesting.claimRewardTVS(2);
        uint256 nftC = beforeC;

        // Merge nftB into nftA while specifying projectIds that mismatch (project 1 vs project 2)
        uint256[] memory projectIds = new uint256[](2);
        uint256[] memory nftIds = new uint256[](2);
        projectIds[0] = 1;
        projectIds[1] = 2;
        nftIds[0] = nftC;
        nftIds[1] = nftB;

        vm.prank(address(this));
        vesting.mergeTVS(0, nftA, projectIds, nftIds);
        //mergedNFT ends up with 5 ether allocation, instead of 15 ether less 5% fee
       
    }
```

### Mitigation

Check if NFT is from a particular project before merging
  