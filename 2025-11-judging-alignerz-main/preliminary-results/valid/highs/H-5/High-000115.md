# [000115] Incorrect fee calculation logic in FeesManager.sol will cause a loss of funds for users with multi-flow TVSs
  
  ### Summary

Incorrect fee calculation logic in FeesManager.sol will cause a direct loss of funds for users with multi-flow TVSs as the protocol subtracts cumulative fees from individual vesting flows.

### Root Cause

In src/contracts/vesting/feesManager/FeesManager.sol, the function calculateFeeAndNewAmountForOneTVS incorrectly subtracts the total accumulated feeAmount from the current flow's amounts[i] instead of subtracting only the fee calculated for that specific flow.

### Internal Pre-conditions

1-A TVS must contain more than one vesting flow (multiple amounts in the Allocation struct).
2-A Split or Merge fee must be set (> 0).


### External Pre-conditions

None

### Attack Path

1-User holds a TVS with 2 flows of 1000 tokens each.
2-User calls splitTVS.
3-Loop i=0: Fee is 100. TotalFee is 100. Amount becomes 900.
4-Loop i=1: Fee is 100. TotalFee is 200. Amount becomes 1000 - 200 = 800.
5-User loses 100 extra tokens on the second flow.


### Impact

Users suffer an approximate loss equal to sum(previous_fees) for every subsequent flow in their vesting schedule. This is a direct leak of value.

### PoC

```solidity
// See test_PoC_3_FeeMath_CumulativeSubtraction in AlignerzAdditionalPoC.t.sol
function test_PoC_3_FeeMath_CumulativeSubtraction() public {
    uint256[] memory amounts = new uint256[](2);
    amounts[0] = 1000;
    amounts[1] = 1000;
    uint256 feeRate = 1000; // 10%
    
    // ... harness setup ...
    uint256[] memory results = harness.testBadMathLogic(feeRate, amounts);

    assertEq(results[0], 900, "Flow 0 correct");
    assertEq(results[1], 800, "Flow 1 incorrect (should be 900)");
}
```

### Mitigation

Update the logic to subtract only the current fee:
```solidity
uint256 currentFee = calculateFeeAmount(feeRate, amounts[i]);
feeAmount += currentFee;
newAmounts[i] = amounts[i] - currentFee;
```
  