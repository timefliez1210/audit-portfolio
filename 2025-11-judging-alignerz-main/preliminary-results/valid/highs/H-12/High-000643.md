# [000643] Inverted token comparison will cause zero dividends for legitimate holders and incorrect payments to wrong token holders as the function returns early for matching tokens
  
  ### Summary

The inverted conditional logic in `A26ZDividendDistributor.sol:141` will cause legitimate TVS holders with the correct token to receive zero dividends while holders of incompatible tokens may receive incorrect dividend payments, as the function returns 0 when tokens match (when it should calculate) and continues processing when they don't match (when it should return 0).

### Root Cause

In `A26ZDividendDistributor.sol:141`, the `getUnclaimedAmounts()` function uses `if (address(token) == address(vesting.allocationOf(nftId).token)) return 0;` which returns 0 when the tokens MATCH, when the correct logic should return 0 when they DON'T match. The comparison operator should be `!=` instead of `==`.


### Internal Pre-conditions

1. Dividend distributor needs to be deployed with a specific `token` address
2. TVS holders need to have allocations with either matching or non-matching token addresses
3. Owner needs to call `setDividends()` to snapshot dividend entitlements
4. Distributor needs to be funded with stablecoin for distributions

### External Pre-conditions

None required - this is a logic error that affects all dividend calculations.

### Attack Path

This is a vulnerability path affecting legitimate users:

1. **Owner deploys dividend distributor** for Token A holders
2. **User1 owns NFT with TVS allocated in Token A** (should receive dividends)
3. **User2 owns NFT with TVS allocated in Token B** (should receive nothing)
4. **Owner calls `setDividends()`** to calculate entitlements
5. **Function calls `getUnclaimedAmounts()` for each NFT**
6. **For User1 (Token A matches):** function returns 0 immediately (WRONG)
7. **For User2 (Token B doesn't match):** function continues and calculates dividends using wrong token data (WRONG)
8. **User1 receives 0 dividends** despite being legitimate holder
9. **User2 may receive dividends** despite having wrong token

### Impact

**Impact**

The entire dividend distribution system is broken:
- Legitimate token holders receive zero dividends
- Wrong token holders may receive undeserved dividends (depending on their TVS data)
- Protocol fails to reward its actual participants
- Users with correct tokens lose 100% of their expected dividend income

If distributor holds $100k in dividends for 10 Token A holders, all 10 receive nothing while arbitrary Token B holders may drain the funds.

### PoC

```solidity
// Setup dividend distributor for Token A
address tokenA = address(0xAAA);
dividendDistributor = new A26ZDividendDistributor(
    address(vesting),
    address(nft),
    address(usdc),
    block.timestamp,
    90 days,
    tokenA
);

// User has TVS with Token A (should get dividends)
uint256 nftId = 1;
// allocationOf[nftId].token = tokenA

// Current buggy behavior
uint256 dividends = dividendDistributor.getUnclaimedAmounts(nftId);
assertEq(dividends, 0); // Wrong! Should be > 0

// User with Token B (shouldn't get dividends)
uint256 nftId2 = 2;
// allocationOf[nftId2].token = tokenB (different)

uint256 dividends2 = dividendDistributor.getUnclaimedAmounts(nftId2);
// May return non-zero (wrong calculation on wrong token)

// With fix:
// nftId (Token A) gets correct dividend amount
// nftId2 (Token B) gets 0
```

### Mitigation

nvert the comparison operator in `A26ZDividendDistributor.sol:141`:

```solidity
function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
    // Fixed: Return 0 when tokens DON'T match
    if (address(token) != address(vesting.allocationOf(nftId).token)) return 0;
    
    // Now correctly calculates dividends only for matching token holders
    uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
    uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
    uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
    bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
    uint256 len = amounts.length;
    
    for (uint i; i < len;) {
        if (claimedFlows[i]) {
            unchecked { ++i; }
            continue;
        }
        if (claimedSeconds[i] == 0) {
            amount += amounts[i];
            unchecked { ++i; }
            continue;
        }
        uint256 claimedAmount = claimedSeconds[i] * amounts[i] / vestingPeriods[i];
        uint256 unclaimedAmount = amounts[i] - claimedAmount;
        amount += unclaimedAmount;
        unchecked { ++i; }
    }
    unclaimedAmountsIn[nftId] = amount;
}
```
  