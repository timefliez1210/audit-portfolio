# [001030] Array Length Mismatch in Distribution Functions Causes Transaction Reverts and Incomplete Processing
  
  ### Summary

The use of storage array length as loop boundary while accessing input array elements will cause transaction reverts or incomplete reward distribution for KOL recipients as the owner will attempt to distribute rewards using mismatched array indices, resulting in either out-of-bounds access when the input array is shorter or partial processing when the input array is longer than the internal storage array.

### Root Cause

In `AlignerzVesting.sol` the `distributeRewardTVS()` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L522-L535) uses `rewardProject.kolTVSAddresses.length` from the storage array as the loop boundary but accesses elements from the input parameter `kol[i]` array. Similarly in `AlignerzVesting.sol` the `distributeStablecoinAllocation()` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L537-L550) uses `rewardProject.kolStablecoinAddresses.length` as the loop boundary while accessing the input kol[i] array. This mismatch between the loop counter source and the array being accessed creates a logical error where the iteration count is determined by one array but elements are read from a completely different array, causing index out of bounds errors when the arrays have different lengths or processing wrong addresses when they happen to match in length but contain different elements.

### Internal Pre-conditions

1. Owner needs to call `setTVSAllocation()` or `setStablecoinAllocation()` to populate the storage arrays `kolTVSAddresses` or `kolStablecoinAddresses` with KOL addresses who have pending reward allocations.
2. Time needs to progress past `rewardProject.claimDeadline` to allow the distribution functions to be callable without reverting on the deadline check.
3. At least one KOL needs to have not claimed their rewards during the claim window, leaving their address in the storage array of pending recipients.
4. The storage array length needs to be different from the input array length provided by the caller to trigger the mismatch condition.

### External Pre-conditions

None required. 

### Attack Path

1. Owner calls `setTVSAllocation()` during reward project setup to allocate rewards to three KOLs with addresses Alice, Bob, and Charlie, which populates `rewardProject.kolTVSAddresses` with these three addresses resulting in a storage array of length 3.
2. Time progresses beyond the claim deadline and Alice claims her TVS reward by calling `claimRewardTVS()`, which removes Alice from the `kolTVSAddresses` array through the pop operation, leaving the storage array with two addresses Bob and Charlie with length 2.
3. Owner attempts to distribute remaining rewards to the two unclaimed KOLs by calling `distributeRewardTVS(projectId, [Bob, Charlie])` with an input array containing exactly the two remaining addresses.
4. The function retrieves `len = rewardProject.kolTVSAddresses.length` which equals 2 since only Bob and Charlie remain in storage.
5. The loop executes with `i = 0` and calls `_claimRewardTVS(projectId, kol[0])` which processes Bob correctly from the input array.
6. The loop continues with `i = 1` and calls `_claimRewardTVS(projectId, kol[1])` which processes Charlie correctly from the input array.
7. In this case the function completes successfully by coincidence since the array lengths matched, but if owner had mistakenly provided only one address `[Bob]` in the input array, the loop would still iterate twice due to the storage length being 2, causing `kol[1]` to access a non-existent index and revert with an out of bounds error.
8. Alternatively if owner provides three addresses `[Bob, Charlie, Dave]` thinking they need to match some expected count, the loop only iterates twice based on storage length 2, processing only Bob and Charlie from indices 0 and 1 while completely ignoring Dave at index 2, leaving the third address unprocessed without any indication of the error.
9. The function becomes effectively unusable as the owner must somehow know the exact current length of the internal storage array at call time and provide an input array of exactly that length with the correct addresses in the correct order, which is not documented anywhere and changes dynamically as users claim rewards.

### Impact

The protocol cannot reliably distribute unclaimed rewards to KOL recipients after the claim deadline expires. When the owner attempts to use `distributeRewardTVS()` or `distributeStablecoinAllocation()`, transactions will revert if the provided input array is shorter than the storage array due to out of bounds access, or will silently process only a subset of the provided addresses if the input array is longer than the storage array, leaving some recipients unprocessed. This renders these distribution functions unusable in practice, potentially locking rewards that should be distributed to KOLs who missed the claim window. While alternative functions `distributeRemainingRewardTVS()` and `distributeRemainingStablecoinAllocation()` exist that work correctly, the broken functions remain in the codebase as external functions that can be called and will fail, causing operational confusion and potential loss of functionality if the owner attempts to use them instead of the working alternatives.

### PoC

Save the following as `test/ArrayMismatchTest.t.sol`

forge test --match-contract ArrayMismatchTest -vvvv


```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";

contract ArrayMismatchTest is Test {
    function testDemonstrateArrayMismatch() public pure {
        // Simulate the bug logic
        address[] memory storageArray = new address[](3);
        storageArray[0] = address(0x1);
        storageArray[1] = address(0x2);
        storageArray[2] = address(0x3);
        
        address[] memory inputArray = new address[](2);
        inputArray[0] = address(0x4);
        inputArray[1] = address(0x5);
        
        console.log("=== DEMONSTRATING ARRAY LENGTH MISMATCH ===");
        console.log("");
        console.log("Storage array length:", storageArray.length);
        console.log("Input array length:", inputArray.length);
        console.log("");
        console.log("Buggy loop logic:");
        console.log("uint256 len = storageArray.length;  // Uses storage length = 3");
        console.log("for (uint256 i = 0; i < len; i++) {");
        console.log("    process(inputArray[i]);  // Accesses input array");
        console.log("}");
        console.log("");
        
        uint256 len = storageArray.length;
        console.log("Loop will iterate", len, "times based on storage");
        console.log("");
        
        for (uint256 i = 0; i < len; i++) {
            console.log("Iteration", i);
            if (i < inputArray.length) {
                console.log("  Accessing inputArray[%s]: Success", i);
                console.log("  Address:", uint256(uint160(inputArray[i])));
            } else {
                console.log("  Accessing inputArray[%s]: OUT OF BOUNDS!", i);
                console.log("  Would REVERT here in actual contract");
                break;
            }
        }
        
        console.log("");
        console.log("=== BUG CONFIRMED ===");
        console.log("Storage has 3 elements but input has only 2");
        console.log("Loop tries to access inputArray[2] which does not exist");
        console.log("Result: Transaction REVERTS");
    }
    
    function testOppositeScenario() public pure {
        address[] memory storageArray = new address[](2);
        storageArray[0] = address(0x1);
        storageArray[1] = address(0x2);
        
        address[] memory inputArray = new address[](4);
        inputArray[0] = address(0x4);
        inputArray[1] = address(0x5);
        inputArray[2] = address(0x6);
        inputArray[3] = address(0x7);
        
        console.log("=== OPPOSITE SCENARIO: INPUT LONGER THAN STORAGE ===");
        console.log("");
        console.log("Storage array length:", storageArray.length);
        console.log("Input array length:", inputArray.length);
        console.log("");
        
        uint256 len = storageArray.length;
        console.log("Loop will iterate", len, "times based on storage");
        console.log("");
        
        for (uint256 i = 0; i < len; i++) {
            console.log("Iteration", i);
            console.log("  Processing inputArray[%s]:", i);
            console.log("  Address:", uint256(uint160(inputArray[i])));
        }
        
        console.log("");
        console.log("=== INCOMPLETE PROCESSING ===");
        console.log("Input array has 4 addresses but only 2 were processed");
        console.log("Addresses at indices 2 and 3 were IGNORED");
        console.log("No error, but function is broken");
    }
}
```

### Mitigation

Change the loop boundary to use the input array length instead of the storage array length, and add validation to ensure the caller provides the correct addresses. The corrected implementation should iterate over the provided input array:

```solidity
function distributeRewardTVS(uint256 rewardProjectId, address[] calldata kol) external {
    RewardProject storage rewardProject = rewardProjects[rewardProjectId];
    require(block.timestamp > rewardProject.claimDeadline, Deadline_Has_Not_Passed());
    
    uint256 len = kol.length;  // Use input array length
    for (uint256 i; i < len;) {
        _claimRewardTVS(rewardProjectId, kol[i]);
        unchecked {
            ++i;
        }
    }
}

function distributeStablecoinAllocation(uint256 rewardProjectId, address[] calldata kol) external {
    RewardProject storage rewardProject = rewardProjects[rewardProjectId];
    require(block.timestamp > rewardProject.claimDeadline, Deadline_Has_Not_Passed());
    
    uint256 len = kol.length;  // Use input array length
    for (uint256 i; i < len;) {
        _claimStablecoinAllocation(rewardProjectId, kol[i]);
        unchecked {
            ++i;
        }
    }
}
```
  