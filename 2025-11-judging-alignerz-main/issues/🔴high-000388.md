# [000388] Incorrect Fee Deduction Logic leads to excessive fee charging for multi-flow TVS
  
  ### Summary

The function 
```
function calculateFeeAndNewAmountForOneTVS(uint256 feeRate, uint256[] memory amounts, uint256 length) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
        for (uint256 i; i < length;) {
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;
        }
    }
```
in `FeesManager.sol` incorrectly calculates the new token amounts after fee deduction for users holding TVS that contain multiple flows. The logic subtracts the cumulative total of all fees calculated so far from the current flow's amount, rather than subtracting only the fee specific to that flow.

### Root Cause

In `FeesManager.sol` the `calculateFeeAndNewAmountForOneTVS` function erroneously subtracts the cumulative `feeAmount` from the current token flow `amounts[i]` instead of subtracting only the fee calculated for that specific flow.

The logic `newAmounts[i] = amounts[i] - feeAmount;` uses feeAmount (which is the running total of all fees calculated so far) instead of the fee specific to the current iteration.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. User calls mergeTVS (or splitTVS) on a TVS that contains 3 vesting flows with the following amounts: [10,000, 20,000, 30,000].
2. The protocol is configured with a feeRate of 200 (2%).
3. The contract calls FeesManager.calculateFeeAndNewAmountForOneTVS.
4. Iteration 0 (Amount: 10,000):
-   The contract calculates the fee: 10,000 * 2% = 200.
-   The feeAmount accumulator becomes 200.
- newAmounts[0] is set to $10,000 - 200 = 9,800$.(Correct).
5. Iteration 1 (Amount: 20,000):
- The contract calculates the fee: 20,000 * 2% = 400.
- The feeAmount accumulator updates to $200 + 400 = 600$.
- The Bug: newAmounts[1] is set to $20,000 - 600 = 19,400$.
- Result: The user essentially paid the fee for Flow 0 (200) again inside Flow 1.
6. Iteration 2 (Amount: 30,000):
- The contract calculates the fee: 30,000 * 2% = 600.
- The feeAmount accumulator updates to $600 + 600 = 1,200$.
- The Bug: newAmounts[2] is set to $30,000 - 1,200 = 28,800$.
- Result: The user paid the cumulative fees of Flow 0 and Flow 1 (600) again inside Flow 2. 

### Impact

Instead of receiving the correct total of 58,800 tokens, the user receives 58,000 tokens. They suffer a permanent loss of 800 tokens due to the cumulative deduction error

### PoC

_No response_

### Mitigation

```
function calculateFeeAndNewAmountForOneTVS(uint256 feeRate, uint256[] memory amounts, uint256 length) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
        for (uint256 i; i < length;) {
++            uint256 currentFee = calculateFeeAmount(feeRate, amounts[i]); // Calculate for this flow
++            newAmounts[i] = amounts[i] - currentFee;                      // Deduct ONLY this flow's fee
++            feeAmount += currentFee;                                      // Add to global accumulator
 --              feeAmount += calculateFeeAmount(feeRate, amounts[i]);
 --              newAmounts[i] = amounts[i] - feeAmount;  
           }
        }
   }
```
  