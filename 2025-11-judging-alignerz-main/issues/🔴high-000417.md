# [000417] Cumulative merge/split fee miscalculation burns TVS flow balances.
  
  https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169-L173 writes to `newAmounts[i]` without allocating the array, so any merge/split that reaches this code reverts with an out‑of‑bounds panic. This is the allocation bug i mentioned [here](https://github.com/dualguard/2025-11-alignerz-x15-eth/issues/2)

But even after allocating, the fee math is wrong. The loop accrues `feeAmount` across flows and subtracts the running total (`newAmounts[i] = amounts[i] - feeAmount`). Example with two flows of 100 each and a 1% fee: `feeAmount` ends at 2 but `newAmounts` become [99,98], so sum(newAmounts)+feeAmount=197 < 200 and 1 token is silently burned. 

Only the final feeAmount is sent to the treasury (https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1013-L1023 for merge, https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1067-L1071 for split). 

There’s no invariant check to detect the loss. You likely want per-flow fees (`fee = ...; feeAmount += fee; newAmounts[i] = amounts[i] - fee;`) plus a sum check.

## Impact
I consider the impact as High because merge/split charges a cumulative fee per flow, so claimable amounts shrink and tokens get stuck/burned on every call. Users’ funds are directly at risk during normal use. No compensating transfer occurs.

I consider the likelihood any user calling `mergeTVS`/`splitTVS` after the array-allocation fix hits this path and overpays. No exotic preconditions.

## POC
The poc test allocates the output array then runs the production fee loop: two 100 ETH flows with a 1% fee end up as [99, 98] with a 2 ETH fee, leaving 1 ETH unaccounted (`originalSum - finalSum == 1 ether`), proving the cumulative-fee burn.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import "../src/contracts/vesting/feesManager/FeesManager.sol";

// Harness that mirrors the production fee loop but allocates the output array
// so we can exercise the cumulative-fee bug.
contract FeeMathPoC is FeesManager {
    function calculateWithAllocation(uint256 feeRate, uint256[] memory amounts)
        external
        pure
        returns (uint256 feeAmount, uint256[] memory newAmounts)
    {
        uint256 length = amounts.length;
        newAmounts = new uint256[](length);
        for (uint256 i; i < length;) {
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;
            unchecked {
                ++i;
            }
        }
    }
}

contract FeesManagerPoCTest is Test {
    FeeMathPoC poc;

    function setUp() public {
        poc = new FeeMathPoC();
    }

    function testFeeMathBurnsSecondFlowDueToCumulativeFee() public {
        uint256[] memory flows = new uint256[](2);
        flows[0] = 100 ether;
        flows[1] = 100 ether;

        // 1% fee; production math subtracts the running fee from each flow.
        (uint256 feeAmount, uint256[] memory newAmounts) = poc.calculateWithAllocation(100, flows);

        assertEq(feeAmount, 2 ether, "fees accumulate across flows");
        assertEq(newAmounts[0], 99 ether, "first flow has single fee");
        assertEq(newAmounts[1], 98 ether, "second flow loses cumulative fee");

        uint256 originalSum = flows[0] + flows[1];
        uint256 finalSum = newAmounts[0] + newAmounts[1] + feeAmount;
        assertEq(originalSum - finalSum, 1 ether, "one ether silently disappears");
    }
}

```

## Recommendation
Allocate `newAmounts = new uint256[](length)` and change the subtraction to per-flow

  