# [000418] Zero-length array writes make merge/split TVS revert (fee calc & split array allocation missing).
  
  Both merge and split flows revert before doing any work. [protocol/src/contracts/vesting/feesManager/FeesManager.sol (line 169)](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L169): `calculateFeeAndNewAmountForOneTVS` returns an unallocated `newAmounts`. The loop writes `newAmounts[i]` with length 0, so `mergeTVS`/`splitTVS` revert on the first iteration with an out-of-bounds memory write.

[protocol/src/contracts/vesting/AlignerzVesting.sol (line 1110)](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1110): `_computeSplitArrays` builds an Allocation memory alloc but never allocates the dynamic arrays. Writing `alloc.amounts[j]` etc. also reverts immediately, so `splitTVS` cannot succeed.

Together this makes merge and split permanently unusable

## Impact
High severity â€” impact is high (merge/split flows are permanently unusable, a core feature DoS), likelihood is high (every call reverts deterministically and no special conditions are needed).

## POC
Place tests in `AlignerzVestingProtocolTest.t.sol` and run

The poc test hit the zero-length array writes in both flows: `test_splitTVS_RevertsDueToUnallocatedArrays` and `test_mergeTVS_RevertsDueToUnallocatedArrays` set up reward projects, mint NFTs to bidders, then show `splitTVS`/`mergeTVS` revert immediately when `calculateFeeAndNewAmountForOneTVS`/`_computeSplitArrays` try to write into unallocated memory

```solidity
function test_splitTVS_RevertsDueToUnallocatedArrays() public {
        vm.startPrank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 7 days);

        address[] memory kols = new address[](1);
        kols[0] = bidders[0];
        uint256[] memory tvsAmounts = new uint256[](1);
        tvsAmounts[0] = 100 ether;

        token.approve(address(vesting), tvsAmounts[0]);
        vesting.setTVSAllocation(0, tvsAmounts[0], 30 days, kols, tvsAmounts);
        vm.stopPrank();

        vm.prank(bidders[0]);
        vesting.claimRewardTVS(0);
        uint256 nftId = nft.getTotalMinted();

        uint256[] memory percentages = new uint256[](2);
        percentages[0] = 5_000;
        percentages[1] = 5_000;

        vm.prank(bidders[0]);
        vm.expectRevert();
        vesting.splitTVS(0, percentages, nftId);
    }

    function test_mergeTVS_RevertsDueToUnallocatedArrays() public {
        vm.startPrank(projectCreator);
        vesting.launchRewardProject(address(token), address(usdt), block.timestamp, 7 days);

        address[] memory kols = new address[](2);
        kols[0] = bidders[0];
        kols[1] = bidders[1];
        uint256[] memory tvsAmounts = new uint256[](2);
        tvsAmounts[0] = 100 ether;
        tvsAmounts[1] = 50 ether;

        token.approve(address(vesting), tvsAmounts[0] + tvsAmounts[1]);
        vesting.setTVSAllocation(0, tvsAmounts[0] + tvsAmounts[1], 30 days, kols, tvsAmounts);
        vm.stopPrank();

        vm.prank(bidders[0]);
        vesting.claimRewardTVS(0);
        uint256 mergedNftId = nft.getTotalMinted();

        vm.prank(bidders[1]);
        vesting.claimRewardTVS(0);
        uint256 nftToMerge = nft.getTotalMinted();

        vm.prank(bidders[1]);
        nft.transferFrom(bidders[1], bidders[0], nftToMerge);

        uint256[] memory projectIds = new uint256[](1);
        projectIds[0] = 0;
        uint256[] memory nftIds = new uint256[](1);
        nftIds[0] = nftToMerge;

        vm.prank(bidders[0]);
        vm.expectRevert();
        vesting.mergeTVS(0, mergedNftId, projectIds, nftIds);
    }
```

## Recommendation
Allocate new `uint256[](length)` in `calculateFeeAndNewAmountForOneTVS`, and allocate each alloc array (amounts/vestingPeriods/vestingStartTimes/claimedSeconds/claimedFlows) to `nbOfFlows` in `_computeSplitArrays`
  