# [000665] Incorrect remaining token amounts after merge or split of TVS
  
  ### Summary

The cumulative fee calculation in `calculateFeeAndNewAmountForOneTVS()` causes disproportionate financial loss for TVS holders performing split or merge operations as the function incorrectly subtracts the accumulated total fees from each individual TVS portion instead of subtracting only the individual fee. It results in later TVS portions in the batch being charged exponentially more fees than suposed to.

### Root Cause


https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L171-L172
In `calculateFeeAndNewAmountForOneTVS()`, `feeAmount` is a cumulative variable that accumulates fees across all iterations but this cumulative total is then incorrectly subtracted from each individual amount.
```solidity
for (uint256 i; i < length; ) {
    feeAmount += calculateFeeAmount(feeRate, amounts[i]);// Accumulates TOTAL fees
@>>> newAmounts[i] = amounts[i] - feeAmount;//Subtracts TOTAL fees from individual TVS
}
```

What happens in a TVS split scenario:
With the current implementation causes and with a splitFee of 0.5%:

1. First TVS portion (index 0): `feeAmount = fee₀`, `newAmounts[0] = amounts[0] - fee₀`  
(pays 0.5% correctly)

2. Second TVS portion (index 1): `feeAmount = fee₀ + fee₁`, `newAmounts[1] = amounts[1] - (fee₀ + fee₁)` 
(pays 0.5% + portion of first TVS's fee)

3. Third TVS portion (index 2): `feeAmount = fee₀ + fee₁ + fee₂`, `newAmounts[2] = amounts[2] - (fee₀ + fee₁ + fee₂)` 
(pays 0.5% + portions of all previous fees)

When a user calls `mergeTVS()` or `splitTVS()`, the remaining token amounts after applying fees are calculated incorrectly, resulting in users losing more than intended.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. User1 owns multiple TVSs (NFTs).
2. User1 calls `mergeTVS()` or `splitTVS()` on one or more TVSs.
3. The function calculates the merge/split fees correctly.
4. However, the remaining amounts after fees are miscalculated and assigned to the resulting TVS.
5. As a result, User1 receives less than the expected token amounts, effectively losing part of their allocation.
6. This can be repeated for multiple merges or splits, compounding the loss across several operations.

### Impact

- Users lose funds
- Users lose dividends if they are supposed to have some.

### PoC


1. Modify `calculateFeeAndNewAmountForOneTVS()` in FeesManager.sol as follows : 
```solidity
    function calculateFeeAndNewAmountForOneTVS(
        uint256 feeRate,
        uint256[] memory amounts,
        uint256 length
    ) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length); // <<< line to add
        for (uint256 i; i < length; ) {
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;
            i++; // <<< line to add
        }
    }
```    
(These changes are necessary to ensure the function executes as intended).


2. Add the following test in AlignerzVestingProtocolTest.t.sol and run the following command :
```solidity 
forge test --match-test test3calculateFeeAndNewAmountForOneTVS
```
```solidity 
    function test3calculateFeeAndNewAmountForOneTVS() public {
        uint feeRate = 300; //3%
        uint256 length = 4;

        uint256[] memory amounts = new uint256[](length);

        amounts[0] = 1000;
        amounts[1] = 2000;
        amounts[2] = 1000;
        amounts[3] = 3000;

        uint256 feeAmount;
        uint256[] memory newAmounts;
        (feeAmount, newAmounts) = vesting.calculateFeeAndNewAmountForOneTVS(
            feeRate,
            amounts,
            length
        );
        console2.log("Using calculateFeeAndNewAmountForOneTVS() we have : ");
        console2.log("newAmounts[0] = ", newAmounts[0]);
        console2.log("newAmounts[1] = ", newAmounts[1]);
        console2.log("newAmounts[2] = ", newAmounts[2]);
        console2.log("newAmounts[3] = ", newAmounts[3]);
        console2.log("While we are supposed to have :");
        console2.log(
            "newAmounts[0] = ",
            amounts[0] - ((amounts[0] * feeRate) / 10_000)
        );
        console2.log(
            "newAmounts[1] = ",
            amounts[1] - ((amounts[1] * feeRate) / 10_000)
        );
        console2.log(
            "newAmounts[2] = ",
            amounts[2] - ((amounts[2] * feeRate) / 10_000)
        );
        console2.log(
            "newAmounts[3] = ",
            amounts[3] - ((amounts[3] * feeRate) / 10_000)
        );
    }
```
### Logs

```solidity
[PASS] test3calculateFeeAndNewAmountForOneTVS() (gas: 49070)
Logs:
  Using calculateFeeAndNewAmountForOneTVS() we have : 
  newAmounts[0] =  970
  newAmounts[1] =  1910
  newAmounts[2] =  880
  newAmounts[3] =  2790
  While we are supposed to have :
  newAmounts[0] =  970
  newAmounts[1] =  1940
  newAmounts[2] =  970
  newAmounts[3] =  2910
```

### Mitigation

``` solidity
function calculateFeeAndNewAmountForOneTVS(
    uint256 feeRate, 
    uint256[] memory amounts, 
    uint256 length
) public pure returns (
    uint256 feeAmount, 
    uint256[] memory newAmounts
) {
    newAmounts = new uint256[](length);
    
    for (uint256 i; i < length;) {
        // Calculate fee for THIS amount only
        uint256 currentFee = calculateFeeAmount(feeRate, amounts[i]);
        
        // Accumulate total fees (for return value)
        feeAmount += currentFee;
        
        // Subtract only the individual fee from this amount
        newAmounts[i] = amounts[i] - currentFee;
        
        ++i; 
    }
}
```

  