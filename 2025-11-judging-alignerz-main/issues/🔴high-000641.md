# [000641] Uninitialized memory struct arrays will cause complete DoS of split operations for all users as the function attempts to write to zero-length arrays
  
  ### Summary

The missing array initialization in `AlignerzVesting.sol:1113-1141` will cause a complete denial of service for all split operations as any user attempting to call `splitTVS()` will trigger Panic(0x32) from attempting to assign values to uninitialized memory arrays in the returned struct.

### Root Cause

In `AlignerzVesting.sol:1113-1141`, the `_computeSplitArrays()` function returns an `Allocation memory` struct but never initializes any of its five dynamic arrays (`amounts`, `vestingPeriods`, `vestingStartTimes`, `claimedSeconds`, `claimedFlows`). Memory structs in Solidity do not automatically allocate storage for dynamic arrays, so attempting to write `alloc.amounts[j] = ...` tries to access index 0 of a zero-length array.

### Internal Pre-conditions

1. User needs to own an NFT with a valid TVS allocation
2. The TVS needs to have at least 1 flow
3. User needs to provide valid split percentages that sum to 100%

### External Pre-conditions

None required - this is a pure implementation bug affecting all split attempts.

### Attack Path

This is a vulnerability path (not an attack):

1. **User calls `splitTVS()` with valid split percentages** (e.g., [50%, 50%])
2. **Function internally calls `_computeSplitArrays()`** to compute new TVS allocations
3. **The function attempts to assign `alloc.amounts[0] = ...`** but the array has length 0
4. **Transaction reverts with Panic(0x32)** - array accessed at out-of-bounds index
5. **User cannot split their TVS under any circumstances**

### Impact

Users cannot split their vesting positions at all. The split functionality is entirely unusable with a 100% revert rate. This affects all users regardless of TVS size, token type, or split parameters. There is no workaround - the feature is completely broken.

### PoC

```solidity
// Any attempt to split will fail
uint256 nftId = 1; // User owns NFT with valid TVS
uint256[] memory percentages = new uint256[](2);
percentages[0] = 5000; // 50%
percentages[1] = 5000; // 50%

// This will revert with Panic(0x32)
try vesting.splitTVS(projectId, percentages, nftId) {
    // Never reaches here
} catch Panic(uint errorCode) {
    assert(errorCode == 0x32); // Array accessed at out-of-bounds
}

// User cannot split their TVS under any circumstances
// Feature is completely non-functional
```

### Mitigation

Initialize all dynamic arrays before using them in `AlignerzVesting.sol:1113-1141`:

```solidity
function _computeSplitArrays(
    Allocation storage allocation,
    uint256 percentage,
    uint256 nbOfFlows
) internal view returns (Allocation memory alloc) {
    // Initialize all dynamic arrays with proper size
    alloc.amounts = new uint256[](nbOfFlows);
    alloc.vestingPeriods = new uint256[](nbOfFlows);
    alloc.vestingStartTimes = new uint256[](nbOfFlows);
    alloc.claimedSeconds = new uint256[](nbOfFlows);
    alloc.claimedFlows = new bool[](nbOfFlows);
    
    // Load base data once for gas efficiency
    uint256[] memory baseAmounts = allocation.amounts;
    uint256[] memory baseVestings = allocation.vestingPeriods;
    uint256[] memory baseVestingStartTimes = allocation.vestingStartTimes;
    uint256[] memory baseClaimed = allocation.claimedSeconds;
    bool[] memory baseClaimedFlows = allocation.claimedFlows;
    
    // Copy non-array fields
    alloc.assignedPoolId = allocation.assignedPoolId;
    alloc.token = allocation.token;
    
    // Now safe to populate arrays
    for (uint256 j; j < nbOfFlows;) {
        alloc.amounts[j] = (baseAmounts[j] * percentage) / BASIS_POINT;
        alloc.vestingPeriods[j] = baseVestings[j];
        alloc.vestingStartTimes[j] = baseVestingStartTimes[j];
        alloc.claimedSeconds[j] = baseClaimed[j];
        alloc.claimedFlows[j] = baseClaimedFlows[j];
        unchecked { ++j; }
    }
}
```

  