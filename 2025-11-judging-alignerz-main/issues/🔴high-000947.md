# [000947] Hardcoded poolId=0 in claimRefund() Prevents Users From Claiming Refunds
  
  ### Summary

The claimRefund() function hardcodes poolId = 0 when constructing the merkle leaf for verification, creating a mismatch with the off chain backend that generates merkle proofs using users actual bid pool IDs. This causes all refund claims to fail with Invalid_Merkle_Proof(), permanently locking user funds in the contract. 

### Root Cause

When users bid on a project, they can be assigned to different pools (pool 0, 1, 2, etc also we should forget that owner is able to create up to 10 pools and which each should have each index) based on the project's allocation strategy. If a bid is rejected, the user should be able to claim a refund by providing a merkle proof generated by the off chain backend.
However, the claimRefund() function always constructs the merkle leaf using poolId = 0, regardless of which pool the user actually bid for.

> [https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L835](url)

```solidity 
function claimRefund(uint256 projectId, uint256 amount, bytes32[] calldata merkleProof) external {
    BiddingProject storage biddingProject = biddingProjects[projectId];
    require(biddingProject.claimDeadline > block.timestamp, Deadline_Has_Passed());

    Bid storage bid = biddingProject.bids[msg.sender];
    require(bid.amount > 0, No_Bid_Found());

    uint256 poolId = 0; // @audit Always hardcoded to 0
    
    // Construct leaf with hardcoded poolId
    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount, projectId, poolId));
    require(!claimedRefund[leaf], Already_Claimed());
    require(MerkleProof.verify(merkleProof, biddingProject.refundRoot, leaf), Invalid_Merkle_Proof());
    
    claimedRefund[leaf] = true;
    biddingProject.totalStablecoinBalance -= amount;
    biddingProject.stablecoin.safeTransfer(msg.sender, amount);

    emit BidRefunded(projectId, msg.sender, amount);
}
```
As to why this breaks: The off chain backend generates refund merkle proofs based on users' actual allocation data. Looking at the accepted bid flow for context:
```solidity
function claimNFT(
    uint256 projectId,
    uint256 poolId,  // User provides their actual pool
    uint256 amount,
    bytes32[] calldata merkleProof
) external {
    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount, projectId, poolId));
    require(MerkleProof.verify(merkleProof, biddingProject.poolRoots[poolId], leaf), Invalid_Merkle_Proof());
    // ...
}
```
For accepted bids, users provide their actual poolId and the leaf is constructed using that value. The backend naturally generates refund proofs following the same pattern using the user's actual pool assignment.
The mismatch:
Offchain backend generates: leaf = hash(user, amount, projectId, actualPoolId) where actualPoolId could be 1, 2, 3,
Contract expects: leaf = hash(user, amount, projectId, 0) always

When these don't match, the merkle proof verification fails.

### Internal Pre-conditions

none

### External Pre-conditions

none

### Attack Path

none

### Impact

Fund loss scenario:
1.Project launches with 3 pools (poolId: 0, 1, 2)
2.User Alice bids and is evaluated for pool 2 but rejected
3.Backend generates refund merkle tree with leaf: hash(alice, 1000 USDC, projectId, 2)
4.Alice calls claimRefund() with her proof
5.Contract constructs leaf as: hash(alice, 1000 USDC, projectId, 0)
6.Merkle verification fails because the leaves don't match
7.Alice cannot claim her 1000 USDC refund
8.Funds are permanently locked until admin manually intervenes, also this is a DoS that leads to fund loss for users.

### PoC

```solidity
 function test_RefundFailsDueToHardcodedPoolId() public {
        // Setup project with multiple pools
        vm.startPrank(projectCreator);
        vesting.launchBiddingProject(address(token), address(usdt), block.timestamp, block.timestamp + 1000, "0x0", true);
        
        vesting.createPool(0, 1_000_000 ether, 0.01 ether, true);  // Pool 0
        vesting.createPool(0, 1_000_000 ether, 0.02 ether, false); // Pool 1
        vesting.createPool(0, 1_000_000 ether, 0.03 ether, false); // Pool 2
        
        // User bids
        address user = makeAddr("user");
        address[] memory users = new address[](1);
        users[0] = user;
        vesting.addUsersToWhitelist(users, 0);
        vm.stopPrank();
        usdt.mint(user, 1000 ether);
        vm.startPrank(user);
        usdt.approve(address(vesting), 1000 ether);
        vesting.placeBid(0, 1000 ether, 180 days);
        vm.stopPrank();

        // Backend evaluates bid for pool 2 but rejects it
        // Backend generates refund proof using poolId=2
        // Note: CompleteMerkle requires at least 2 leaves, so we add a dummy entry
        bytes32[] memory leaves = new bytes32[](2);
        leaves[0] = keccak256(abi.encodePacked(user, uint256(1000 ether), uint256(0), uint256(2))); // poolId=2
        leaves[1] = keccak256(abi.encodePacked(makeAddr("dummy"), uint256(1 ether), uint256(0), uint256(2))); // dummy entry
        
        CompleteMerkle m = new CompleteMerkle();
        bytes32 testRefundRoot = m.getRoot(leaves);
        bytes32[] memory proof = m.getProof(leaves, 0);

        // Finalize with this refund root
        vm.prank(projectCreator);
        bytes32[] memory poolRoots = new bytes32[](3);
        vesting.finalizeBids(0, testRefundRoot, poolRoots, 60);

        // User tries to claim refund with valid proof
        vm.prank(user);
        vm.expectRevert(); // Fails with Invalid_Merkle_Proof
        vesting.claimRefund(0, 1000 ether, proof);
        
        // User's 1000 USDT is stuck
        assertEq(usdt.balanceOf(user), 0);
    }
```

### Mitigation

Add poolId as a function parameter to allow flexibility in merkle leaf construction
  