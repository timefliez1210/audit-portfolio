# [000004] allocationOf interface mismatch will revert dividend accounting for all TVS NFTs
  
  ### Summary

An ABI mismatch between the autogenerated `allocationOf` mapping getter in `AlignerzVesting` and the `IAlignerzVesting` interface used by `A26ZDividendDistributor` causes every call to `A26ZDividendDistributor::getUnclaimedAmounts` (and thus `getTotalUnclaimedAmounts` / dividend setup) to revert, as the distributor attempts to decode a full `Allocation` struct with dynamic arrays from a getter that only returns the static fields of the mapping value.

### Root Cause

The vesting contract exposes `allocationOf` as a public mapping, which generates a getter that only returns the value-type (static) fields of the `Allocation` struct:

```solidity
contract AlignerzVesting {
    struct Allocation {
        uint256[] amounts;
        uint256[] vestingPeriods;
        uint256[] vestingStartTimes;
        uint256[] claimedSeconds;
        bool[] claimedFlows;
        bool isClaimed;
        IERC20 token;
        uint256 assignedPoolId;
    }

@>  mapping(uint256 => Allocation) public allocationOf;
    // ...
}
```

The compiler therefore generates a getter with ABI equivalent to:

```solidity
function allocationOf(uint256 nftId)
    external
    view
    returns (bool isClaimed, address token, uint256 assignedPoolId);
```

you can read more about this behavoiur in the [solidity docs ](https://docs.soliditylang.org/en/latest/contracts.html#getter-functions)

However, the external `IAlignerzVesting` interface used by `A26ZDividendDistributor` declares `allocationOf` as returning the full `Allocation` struct, including all dynamic arrays:

```solidity
interface IAlignerzVesting {
    struct Allocation {
        uint256[] amounts;
        uint256[] vestingPeriods;
        uint256[] vestingStartTimes;
        uint256[] claimedSeconds;
        bool[] claimedFlows;
        bool isClaimed;
        IERC20 token;
        uint256 assignedPoolId;
    }

@>  function allocationOf(uint256 nftId)
@>      external
@>      view
@>      returns (Allocation memory);
}
```

`A26ZDividendDistributor` is wired against this interface and assumes it can read the full struct, including the dynamic arrays, when computing unclaimed amounts:

```solidity
function getUnclaimedAmounts(
    uint256 nftId
) public returns (uint256 amount) {
    if (address(token) == address(vesting.allocationOf(nftId).token))
        return 0;

    uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
    uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
    uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
    bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
    uint256 len = vesting.allocationOf(nftId).amounts.length;
    // ...
}
```

At runtime, the vesting contract encodes only `(isClaimed, token, assignedPoolId)` as the return payload of `allocationOf(uint256)`, but the distributor—via `IAlignerzVesting`—tries to decode that payload as a full `Allocation` struct with dynamic arrays (`amounts`, `vestingPeriods`, etc.). The ABI decoder detects that the data is too short / malformed for the expected struct layout and immediately reverts.

Because every `vesting.allocationOf(nftId)` call in `getUnclaimedAmounts` goes through this mismatched interface, **all** uses of `getUnclaimedAmounts` and `getTotalUnclaimedAmounts` will revert as soon as they try to read the allocation struct, breaking dividend accounting for every TVS NFT.

### Internal Pre-conditions

None

### External Pre-conditions

None

### Attack Path

This is primarily a correctness / availability issue rather than an intentional attack vector, but the failure path looks like:

1. The protocol deploys `AlignerzVesting` and `A26ZDividendDistributor`, wiring the distributor to the vesting contract via the `IAlignerzVesting` interface.
2. A user participates in a vesting project and obtains a TVS NFT; `AlignerzVesting` records an `Allocation` entry in the `allocationOf` mapping for that NFT.
3. The owner attempts to account for or distribute dividends by calling `A26ZDividendDistributor::getUnclaimedAmounts(nftId)` for that NFT (directly or via `getTotalUnclaimedAmounts` / `setUpTheDividends`).
4. Inside `getUnclaimedAmounts`, the distributor calls `vesting.allocationOf(nftId)` via `IAlignerzVesting`; the vesting contract returns a short `(bool,address,uint256)` tuple encoded per the autogenerated getter, but the distributor tries to decode it as a full `Allocation` struct.
5. The ABI decoder detects the mismatch and reverts, causing `getUnclaimedAmounts` (and any higher-level dividend setup function) to revert for every NFT.

### Impact

The affected party is the protocol / TVS ecosystem, which cannot use `A26ZDividendDistributor` to compute or distribute dividends at all:

- Every call that relies on `vesting.allocationOf(nftId)` via `IAlignerzVesting` reverts at the ABI decoding step, so `getUnclaimedAmounts` and `getTotalUnclaimedAmounts` are unusable for real allocations.
- As a result, the protocol cannot reliably compute `totalUnclaimedAmounts` or per-holder dividends, and any dividend distribution flows that depend on these helpers will fail, blocking dividend accounting and distribution for all TVS NFT holders.

### PoC

The following Foundry test (add to `protocol/test/AlignerzVestingProtocolTest.t.sol`) demonstrates that `A26ZDividendDistributor::getUnclaimedAmounts` always reverts when wired against the real `AlignerzVesting` implementation, because the call to `vesting.allocationOf(nftId)` cannot be decoded as a full `Allocation` struct.
add these imports to the top of the file:
```solidity
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {A26ZDividendDistributor} from "../src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol";
```
then add this tests inside the contract
```solidity
   // this is a helper function, POC is the next fn
    function _setupAndFinalizeProjectWithBidder(address bidder) internal {


        // setup bidding project
        vm.startPrank(projectCreator);
        vesting.launchBiddingProject(
            address(token),
            address(usdt),
            block.timestamp,
            block.timestamp + 1_000_000,
            "0x0",
            true
        );
        vesting.createPool(PROJECT_ID, 3_000_000 ether, 0.01 ether, true);

        vesting.addUsersToWhitelist(bidders, PROJECT_ID);
        vm.stopPrank();
        vm.startPrank(bidder);
        usdt.approve(address(vesting), BIDDER_USD);
        uint256 vestingPeriod = 90 days;
        vesting.placeBid(PROJECT_ID, BIDDER_USD, vestingPeriod);
        vm.stopPrank();

        BidInfo memory bid = BidInfo({
            bidder: bidder,
            amount: BIDDER_USD,
            vestingPeriod: vestingPeriod,
            poolId: 0,
            accepted: true
        });
        BidInfo[] memory bids = new BidInfo[](2);
        bids[0] = bid;
        bids[1] = bid;
        bytes32 poolRoot = generateMerkleProofs(bids, 0);
        bytes32[] memory merkleRoots = new bytes32[](1);
        merkleRoots[0] = poolRoot;

        vm.prank(projectCreator);
        vesting.finalizeBids(PROJECT_ID, "", merkleRoots, 60 days);

    }
    function test_POC_dividendDistributor_allocationOf_getter_reverts() public {
        address holder = bidders[0];
        _setupAndFinalizeProjectWithBidder(holder);

        vm.startPrank(holder);
        uint256 nftId = vesting.claimNFT(
            PROJECT_ID,
            0,
            BIDDER_USD,
            bidderProofs[holder]
        );
        vm.stopPrank();

        A26ZDividendDistributor distributor = new A26ZDividendDistributor(
            address(vesting),
            address(nft),
            address(usdt),
            block.timestamp,
            90 days,
            address(token)
        );

        vm.expectRevert();
        distributor.getUnclaimedAmounts(nftId);
    }
```

Run this PoC from the `protocol` directory:

```bash
forge clean && forge test --match-test test_POC_dividendDistributor_allocationOf_getter_reverts -vv
```

### Mitigation

Align the `allocationOf` ABI used by `A26ZDividendDistributor` with the actual implementation in `AlignerzVesting`:

- Either expose a dedicated view function in `AlignerzVesting` that returns the full `Allocation` struct (including the dynamic arrays), and update `IAlignerzVesting` and the distributor to call that function instead of the autogenerated mapping getter; or
- Change the interface and distributor logic to match the actual autogenerated getter signature, and fetch any required dynamic data through separately exposed accessors.

The key requirement is that the function signature and return type declared in `IAlignerzVesting` must exactly match the implementation in `AlignerzVesting`; once the ABI is consistent, `A26ZDividendDistributor::getUnclaimedAmounts` will be able to safely read allocations and compute unclaimed amounts without reverting.


  