# [000669] Unbounded loop allows DoS of `getTotalUnclaimedAmounts()`.
  
  ### Summary

The use of an unbounded `for` loop based directly on `nft.getTotalMinted()` causes a Denial of Service when the total minted supply grows.
As a result, global unclaimed amount calculation (`getTotalUnclaimedAmounts()`) can become permanently unusable.

### Root Cause

https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol#L128
In `getTotalUnclaimedAmounts()` the protocol iterates over:
```solidity
uint256 len = nft.getTotalMinted();
for (uint256 i; i < len; ) { ... }
```
There isn't any upper bound, batching, or gas-safe mechanism.
This design is unsafe because:
- `len` can grow arbitrarily large as more NFTs are minted
- Gas grows linearly with `len`
- The loop performs heavy operations such as:
    - `safeOwnerOf(i)`
    - `getUnclaimedAmounts(i)`
  
Thus, the function becomes non-scalable and can be pushed into permanent revert as soon as len exceeds the gas limit.


### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. Attacker mints NFTs repeatedly by placing small bids and claimingNFT, increasing `nft.getTotalMinted()`.
2. When `getTotalMinted()`becomes high enough, calling `getTotalUnclaimedAmounts()` causes gas exhaustion. 

### Impact

The protocol can't compute total unclaimed amounts.
The user can't claim their dividends as `unclaimedAmountsIn[]` is used to calculate the dividends.

### PoC

_No response_

### Mitigation

Use batch processing : 
Instead of iterating over all minted NFTs in a single call, the function should process them in fixed-size batches (like 50 or 100 IDs per call).
This avoids gas exhaustion and prevents the function from reverting as the total minted supply increases.

A typical approach is:
- Call the function once for IDs 0 → 99
- Then again for 100 → 199
- Then 200 → 299, and so on
  