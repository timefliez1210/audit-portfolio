# [000664] All TVS split operations will revert due to uninitialized memory arrays in `_computeSplitArrays()`.
  
  ### Summary

The failure to initialize memory arrays in `_computeSplitArrays()` before accessing their indices will cause all split operations to revert with "Index out of bounds" errors as Solidity memory structs are initialized with zero-length arrays by default. It makes the entire TVS split feature completely unusable and permanently breaking a core protocol functionality.


### Root Cause

https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/AlignerzVesting.sol#L1121
In `_computeSplitArrays()` the function attempts to write to array indices without first initializing the arrays with proper lengths.
```solidity
        for (uint256 j; j < nbOfFlows;) {
            alloc.amounts[j] = (baseAmounts[j] * percentage) / BASIS_POINT;
            alloc.vestingPeriods[j] = baseVestings[j];
            alloc.vestingStartTimes[j] = baseVestingStartTimes[j];
            alloc.claimedSeconds[j] = baseClaimed[j];
            alloc.claimedFlows[j] = baseClaimedFlows[j];
```
The function never allocates memory for these arrays before attempting to write to them, causing guaranteed reverts on the first array access in the loop.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. User owns a TVS with ID 100 containing 1000 tokens
2. User wants to split into two parts: 70% and 30%
3. User calls `splitTVS(projectId, [7000, 3000], 100)`

### Impact

The entire TVS split functionality is permanently broken and unusable. 
All users attempting to split their TVS will experience transaction reverts.

### PoC

_No response_

### Mitigation


The `_computeSplitArrays()` function must initialize all memory arrays before accessing their indices.
```solidity
function _computeSplitArrays(
    Allocation storage allocation,
    uint256 percentage,
    uint256 nbOfFlows
) internal view returns (Allocation memory alloc) {
    //Initialize all arrays with correct lengths BEFORE accessing
@>> alloc.amounts = new uint256[](nbOfFlows);
@>> alloc.vestingPeriods = new uint256[](nbOfFlows);
@>> alloc.vestingStartTimes = new uint256[](nbOfFlows);
@>> alloc.claimedSeconds = new uint256[](nbOfFlows);
@>> alloc.claimedFlows = new bool[](nbOfFlows);
    
    // Copy scalar fields
    alloc.assignedPoolId = allocation.assignedPoolId;
    alloc.token = allocation.token;
    
    // Now safe to access array indices
    uint256[] memory baseAmounts = allocation.amounts;
    uint256[] memory baseVestings = allocation.vestingPeriods;
    uint256[] memory baseVestingStartTimes = allocation.vestingStartTimes;
    uint256[] memory baseClaimed = allocation.claimedSeconds;
    bool[] memory baseClaimedFlows = allocation.claimedFlows;
    
    for (uint256 j; j < nbOfFlows; ) {
        alloc.amounts[j] = (baseAmounts[j] * percentage) / BASIS_POINT;
        alloc.vestingPeriods[j] = baseVestings[j];
        alloc.vestingStartTimes[j] = baseVestingStartTimes[j];
        alloc.claimedSeconds[j] = baseClaimed[j];
        alloc.claimedFlows[j] = baseClaimedFlows[j];
        
        unchecked { ++j; }
    }
}
```
  