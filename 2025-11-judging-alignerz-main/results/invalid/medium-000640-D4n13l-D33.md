# [000640] nteger underflow will cause DoS when distributing remaining rewards with empty arrays as the loop initializer subtracts from zero
  
  ### Summary

The missing zero-length check in `AlignerzVesting.sol:558` and `AlignerzVesting.sol:585` will cause denial of service when the owner attempts to call distribution functions with empty arrays (all KOLs claimed), as the function initializes the loop counter with `len - 1` which underflows to `type(uint256).max` when `len = 0`.

### Root Cause

In `AlignerzVesting.sol:558`, and line 585, the functions `distributeRemainingRewardTVS()` and `distributeRemainingStablecoinAllocation()` initialize their loop counter as `uint256 i = len - 1` without checking if `len = 0`, causing an underflow that makes `i = type(uint256).max`.

### Internal Pre-conditions

1. Owner needs to have launched a reward project
2. All KOLs need to have claimed their rewards before the deadline (resulting in empty kolTVSAddresses or kolStablecoinAddresses arrays)
3. Owner needs to call `distributeRemainingRewardTVS()` or `distributeRemainingStablecoinAllocation()` after the deadline

### External Pre-conditions

None required - this is an edge case bug in owner functions.

### Attack Path

This is a vulnerability path affecting the owner:

1. **Protocol launches reward project** with allocations for 5 KOLs
2. **All 5 KOLs claim their rewards** before the deadline via `claimRewardTVS()`
3. **Arrays `kolTVSAddresses` and `kolTVSRewards` are empty** (all elements removed via pop)
4. **Deadline passes**
5. **Owner calls `distributeRemainingRewardTVS()`** to clean up (good practice)
6. **Function reads `len = 0`** from `rewardProject.kolTVSAddresses.length`
7. **Function initializes `i = len - 1 = 0 - 1`** which underflows to `2^256 - 1`
8. **Function tries to access `kolTVSAddresses[2^256 - 1]`** which is out of bounds
9. **Transaction reverts** with array access error
10. **Owner cannot call the function** even though it's a legitimate use case

### Impact

The owner cannot clean up reward projects where all KOLs have claimed. This is a minor impact since:
- Only affects owner (not users)
- Only occurs in edge case (100% claim rate)
- Function still fails gracefully with revert

However, it's still a bug that prevents a legitimate function call and produces confusing error messages. The function should handle empty arrays gracefully.


### PoC

``solidity
// Setup: All KOLs have claimed their rewards
// kolTVSAddresses array is now empty (length = 0)

// Owner tries to distribute remaining (none exist)
vm.prank(owner);
try vesting.distributeRemainingRewardTVS(projectId) {
    // Never reaches here
} catch {
    // Reverts with out-of-bounds error
    // Should handle gracefully instead
}
```

### Mitigation

dd zero-length check before loop initialization:

```solidity
function distributeRemainingRewardTVS(uint256 rewardProjectId) external onlyOwner {
    RewardProject storage rewardProject = rewardProjects[rewardProjectId];
    require(block.timestamp > rewardProject.claimDeadline, Deadline_Has_Not_Passed());
    
    uint256 len = rewardProject.kolTVSAddresses.length;
    if (len == 0) return; // Early exit for empty array - FIX
    
    // Now safe to use len - 1
    for (uint256 i = len - 1; rewardProject.kolTVSAddresses.length > 0;) {
        address kol = rewardProject.kolTVSAddresses[i];
        uint256 amount = rewardProject.kolTVSRewards[kol];
        rewardProject.kolTVSRewards[kol] = 0;
        uint256 nftId = nftContract.mint(kol);
        _setAllocation(
            nftId,
            rewardProjectId,
            amount,
            rewardProject.vestingPeriod,
            rewardProject.token
        );
        rewardProject.kolTVSAddresses.pop();
        unchecked { --i; }
    }
}

// Apply same fix to distributeRemainingStablecoinAllocation
function distributeRemainingStablecoinAllocation(uint256 rewardProjectId) external onlyOwner {
    RewardProject storage rewardProject = rewardProjects[rewardProjectId];
    require(block.timestamp > rewardProject.claimDeadline, Deadline_Has_Not_Passed());
    
    uint256 len = rewardProject.kolStablecoinAddresses.length;
    if (len == 0) return; // Early exit for empty array - FIX
    
    for (uint256 i = len - 1; rewardProject.kolStablecoinAddresses.length > 0;) {
        address kol = rewardProject.kolStablecoinAddresses[i];
        uint256 amount = rewardProject.kolStablecoinRewards[kol];
        rewardProject.kolStablecoinRewards[kol] = 0;
        stablecoinContract.transfer(kol, amount);
        rewardProject.kolStablecoinAddresses.pop();
        unchecked { --i; }
    }
}
```
  