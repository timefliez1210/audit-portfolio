# [000277] ABI mismatch in `getUnclaimedAmounts()` causing dividend functionality DoS
  
  ### Summary

`getUnclaimedAmounts()` uses `AlignerzVesting.allocationOf()`, which is an auto-generated getter without dynamic arrays, while the interface requires a full Allocation struct. This results in an ABI mismatch, causing every call to `getUnclaimedAmounts()` and functions that depend on it to revert.

### Root Cause

In `getUnclaimedAmounts()`, the contract fetches the allocation for a given `nftId` directly from `AlignerzVesting` via `vesting.allocationOf(nftId)`:

https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol#L140-L161
```solidity
    function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
@>      if (address(token) == address(vesting.allocationOf(nftId).token)) return 0;
@>      uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
@>      uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
@>      uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
@>      bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
@>      uint256 len = vesting.allocationOf(nftId).amounts.length;
        ...
    }
```

From the `IAlignerzVesting` interface, we can see that `allocationOf()` is expected to return a full Allocation struct which includes dynamic arrays:

https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/interfaces/IAlignerzVesting.sol#L56-L67
```solidity
    struct Allocation {
        uint256[] amounts; // Amount of tokens committed for this allocation for all flows
        uint256[] vestingPeriods; // Chosen vesting duration in seconds for all flows
        uint256[] vestingStartTimes; // start time of the vesting for all flows
        uint256[] claimedSeconds; // Number of seconds already claimed for all flows
        bool[] claimedFlows; // Whether flow is claimed
        bool isClaimed; // Whether TVS is fully claimed
        IERC20 token; // The TVS token
        uint256 assignedPoolId; // Relevant for bidding projects: Id of the Pool (poolId=0; pool#1 / poolId=1; pool#2 /...) - for reward projects it will be 0 as default
    }

    function allocationOf(uint256 nftId) external view returns (Allocation memory);
```

However, in `AlignerzVesting`, `allocationOf()` is a getter auto-generated by the compiler. Solidity’s generated getter does not return the dynamic arrays, it only returns the static fields. 

Inspecting the ABI with the Foundry command `forge inspect AlignerzVesting abi` shows that the actual `allocationOf()` completely omits all dynamic arrays:
```shell
----------+--------------------------------------------------------------------------------+|
| function | allocationOf(uint256) view returns (bool,IERC20,uint256)    |    0xa1ecae65    |
|----------+-------------------------------------------------------------------------------+|                                                        |
```

As a result, when `A26ZDividendDistributor` tries to decode the return data of `allocationOf()` as an Allocation struct with dynamic arrays, it will revert due to the ABI mismatch.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

- Any call to one of the following functions will revert and cause a Denial of Service:
	- getUnclaimedAmounts()
	- getTotalUnclaimedAmounts()
	- setUpTheDividends()
	- setAmounts()

### Impact

`getUnclaimedAmounts()` and all functions that depend on it become unusable. The protocol can no longer query unclaimed tokens for TVSs, configure dividends for TVS holders, or set the amounts required for dividend distribution. This effectively disables core dividend functionality and severely impacts protocol availability.

### PoC

Create a test file `PoC.t.sol` in the `test` folder and place the following code in it:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {Aligners26} from "../src/contracts/token/Aligners26.sol";
import {AlignerzNFT} from "../src/contracts/nft/AlignerzNFT.sol";
import {MockUSD} from "../src/MockUSD.sol";
import {AlignerzVesting} from "../src/contracts/vesting/AlignerzVesting.sol";
import {Upgrades} from "openzeppelin-foundry-upgrades/Upgrades.sol";
import {CompleteMerkle} from "murky/src/CompleteMerkle.sol";
import {A26ZDividendDistributor} from "../src/contracts/A26ZDividendDistributor/A26ZDividendDistributor.sol";

contract PoC is Test {
    AlignerzVesting public vesting;
    Aligners26 public token;
    AlignerzNFT public nft;
    
    A26ZDividendDistributor public distributor;

    MockUSD public usdt;

    address public owner;
    address public projectCreator;
    address[] public bidders;

    // Constants
    uint256 constant NUM_BIDDERS = 20;
    uint256 constant TOKEN_AMOUNT = 26_000_000 ether;
    uint256 constant BIDDER_USD = 1_000 ether;
    uint256 constant PROJECT_ID = 0;

    // Project structure for organization
    struct BidInfo {
        address bidder;
        uint256 amount;
        uint256 vestingPeriod;
        uint256 poolId;
        bool accepted;
    }

    // Track allocated bids and their proofs
    mapping(address => bytes32[]) public bidderProofs;
    mapping(address => uint256) public bidderPoolIds;
    mapping(address => uint256) public bidderNFTIds;
    bytes32 public refundRoot;

    function setUp() public {
        owner = address(this);
        projectCreator = makeAddr("projectCreator");
        vm.deal(projectCreator, 100 ether);

        // Deploy contracts
        usdt = new MockUSD();
        token = new Aligners26("26Aligners", "A26Z");
        nft = new AlignerzNFT("AlignerzNFT", "AZNFT", "https://nft.alignerz.bid/");

        address payable proxy = payable(Upgrades.deployUUPSProxy(
            "AlignerzVesting.sol",
            abi.encodeCall(AlignerzVesting.initialize, (address(nft))))
        );
        vesting = AlignerzVesting(proxy);

        // Set NFT minter to vesting contract
        vm.prank(owner);
        nft.addMinter(proxy);
        vesting.setTreasury(address(1));

        distributor = new A26ZDividendDistributor(
            address(vesting),
            address(nft),
            address(usdt),
            block.timestamp, 
            block.timestamp + 1_000_000,
            address(token)
        );

        // Create bidders with ETH and USDT
        for (uint256 i = 0; i < NUM_BIDDERS; i++) {
            address bidder = makeAddr(string.concat("bidder", vm.toString(i)));
            vm.deal(bidder, 50 ether);
            bidders.push(bidder);
            usdt.mint(bidder, BIDDER_USD);
        }

        // Mint tokens for project creator
        token.transfer(projectCreator, TOKEN_AMOUNT);
        vesting.transferOwnership(projectCreator);

        // Approve tokens for vesting contract
        vm.prank(projectCreator);
        token.approve(address(vesting), TOKEN_AMOUNT);
    }

    // Helper function to create a leaf node for the merkle tree
    function getLeaf(address bidder, uint256 amount, uint256 projectId, uint256 poolId)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(bidder, amount, projectId, poolId));
    }

    // Helper for generating merkle proofs
    function generateMerkleProofs(BidInfo[] memory bids, uint256 poolId) internal returns (bytes32) {
        bytes32[] memory leaves = new bytes32[](bids.length);
        uint256 leafCount = 0;

        // Create leaves for each bid in this pool
        for (uint256 i = 0; i < bids.length; i++) {
            if (bids[i].poolId == poolId && bids[i].accepted) {
                leaves[leafCount] = getLeaf(bids[i].bidder, bids[i].amount, PROJECT_ID, poolId);

                bidderPoolIds[bids[i].bidder] = poolId;
                leafCount++;
            }
        }

        CompleteMerkle m = new CompleteMerkle();
        bytes32 root = m.getRoot(leaves);
        uint256 indexTracker = 0;
        for (uint256 i = 0; i < bids.length; i++) {
            if (bids[i].poolId == poolId && bids[i].accepted) {
                bytes32[] memory proof = m.getProof(leaves, indexTracker);
                bidderProofs[bids[i].bidder] = proof;
                indexTracker++;
            }
        }
        return root;
    }

    // Helper for generating refund proofs
    function generateRefundProofs(BidInfo[] memory bids) internal returns (bytes32) {
        bytes32[] memory leaves = new bytes32[](bids.length);
        uint256 leafCount = 0;
        uint256 poolId = 0;

        // Create leaves for each bid in this pool
        for (uint256 i = 0; i < bids.length; i++) {
            if (!bids[i].accepted) {
                leaves[leafCount] = getLeaf(bids[i].bidder, bids[i].amount, PROJECT_ID, poolId);

                bidderPoolIds[bids[i].bidder] = poolId;
                leafCount++;
            }
        }

        CompleteMerkle m = new CompleteMerkle();
        bytes32 root = m.getRoot(leaves);
        uint256 indexTracker = 0;
        for (uint256 i = 0; i < bids.length; i++) {
            if (!bids[i].accepted) {
                bytes32[] memory proof = m.getProof(leaves, indexTracker);
                bidderProofs[bids[i].bidder] = proof;
                indexTracker++;
            }
        }

        return root;
    }

    function test_GetUnclaimedAmountsABIMismatchReverts() public {
        vm.startPrank(projectCreator);
        vesting.setVestingPeriodDivisor(1);

        // 1. Launch project
        vm.startPrank(projectCreator);
        vesting.launchBiddingProject(address(token), address(usdt), block.timestamp, block.timestamp + 1_000_000, "0x0", true);

        // 2. Create multiple pools with different prices
        vesting.createPool(PROJECT_ID, 3_000_000 ether, 0.01 ether, true);
        vesting.createPool(PROJECT_ID, 3_000_000 ether, 0.02 ether, false);
        vesting.createPool(PROJECT_ID, 4_000_000 ether, 0.03 ether, false);

        // 3. Place bids from different whitelisted users
        vesting.addUsersToWhitelist(bidders, PROJECT_ID);
        vm.stopPrank();
        for (uint256 i = 0; i < NUM_BIDDERS; i++) {
            vm.startPrank(bidders[i]);

            // Approve and place bid
            usdt.approve(address(vesting), BIDDER_USD);

            // Different vesting periods to test variety
            uint256 vestingPeriod = (i % 3 == 0) ? 90 days : (i % 3 == 1) ? 180 days : 365 days;

            vesting.placeBid(PROJECT_ID, BIDDER_USD, vestingPeriod);
            vm.stopPrank();
        }

        // 4. Update some bids
        vm.prank(bidders[0]);
        vesting.updateBid(PROJECT_ID, BIDDER_USD, 180 days);

        // 5. Prepare bid allocations (this would be done off-chain)
        BidInfo[] memory allBids = new BidInfo[](NUM_BIDDERS);

        // Simulate off-chain allocation process
        for (uint256 i = 0; i < NUM_BIDDERS; i++) {
            // Assign bids to pools (in reality, this would be based on some algorithm)
            uint256 poolId = i % 3;
            bool accepted = i < 15; // First 15 bidders are accepted

            allBids[i] = BidInfo({
                bidder: bidders[i],
                amount: BIDDER_USD, // For simplicity, all bids are the same amount
                vestingPeriod: (i % 3 == 0) ? 90 days : (i % 3 == 1) ? 180 days : 365 days,
                poolId: poolId,
                accepted: accepted
            });
        }

        // 6. Generate merkle roots for each pool
        bytes32[] memory poolRoots = new bytes32[](3);
        for (uint256 poolId = 0; poolId < 3; poolId++) {
            poolRoots[poolId] = generateMerkleProofs(allBids, poolId);
        }

        // 7. Generate refund proofs
        refundRoot = generateRefundProofs(allBids);

        // 8. Finalize project with merkle roots
        vm.prank(projectCreator);
        vesting.finalizeBids(PROJECT_ID, refundRoot, poolRoots, 60);
        uint256[] memory nftIds = new uint256[](15);
        // 9. Users claim NFTs with proofs
        for (uint256 i = 0; i < 15; i++) {
            // Only accepted bidders
            address bidder = bidders[i];
            uint256 poolId = bidderPoolIds[bidder];

            vm.prank(bidder);
            uint256 nftId = vesting.claimNFT(PROJECT_ID, poolId, BIDDER_USD, bidderProofs[bidder]);
            nftIds[i] = nftId;
            vm.prank(bidder);
            bidderNFTIds[bidder] = nftId;

            // Verify NFT ownership
            assertEq(nft.ownerOf(nftId), bidder);
        }

        // 10. Calling getTotalUnclaimedAmounts() will revert due to ABI mismatch
        distributor.getTotalUnclaimedAmounts();
    }
}
```

PoC steps 1–9 follow the normal vesting flow, and step 10 calls `getTotalUnclaimedAmounts()` to query all the unclaimed tokens of all the TVSs, which will revert.

Run with:
```shell
forge test --mt test_GetUnclaimedAmountsABIMismatchReverts --force -vvv
```

Output:
```shell
	...
    ├─ [22774] A26ZDividendDistributor::getTotalUnclaimedAmounts()
    │   ├─ [1018] AlignerzNFT::getTotalMinted() [staticcall]
    │   │   └─ ← [Return] 15
    │   ├─ [1680] AlignerzNFT::extOwnerOf(0) [staticcall]
    │   │   └─ ← [Revert] OwnerQueryForNonexistentToken()
    │   ├─ [4318] AlignerzNFT::extOwnerOf(1) [staticcall]
    │   │   └─ ← [Return] bidder0: [0xf0Ad0970EE36C6FaF41575f3736D081ceEb36083]
    │   ├─ [3604] ERC1967Proxy::fallback(1) [staticcall]
    │   │   ├─ [2867] AlignerzVesting::allocationOf(1) [delegatecall]
    │   │   │   └─ ← [Return] false, Aligners26: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 0
    │   │   └─ ← [Return] false, Aligners26: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 0
    │   └─ ← [Revert] EvmError: Revert
    └─ ← [Revert] EvmError: Revert

Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 1.54s (4.91ms CPU time)

Ran 1 test suite in 1.55s (1.54s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)

Failing tests:
Encountered 1 failing test in test/TestPoC-9.sol:PoC
[FAIL: EvmError: Revert] test_GetUnclaimedAmountsABIMismatchReverts() (gas: 19643363)
```


### Mitigation

To minimize changes, introduce a dedicated getter in `AlignerzVesting.sol` instead of relying on the auto-generated mapping getter: 
```diff
+   function getAllocationOf(uint256 nftId) public view returns (Allocation memory) {
+       return allocationOf[nftId];
+   }
```

And add the corresponding `getAllocationOf()` interface into `IAlignerzVesting.sol`:
```diff
+   function getAllocationOf(uint256 nftId) external view returns (Allocation memory);
```

Modify `getUnclaimedAmounts()` in `A26ZDividendDistributor.sol`:
```diff
    function getUnclaimedAmounts(uint256 nftId) public returns (uint256 amount) {
-       if (address(token) == address(vesting.allocationOf(nftId).token)) return 0;
-       uint256[] memory amounts = vesting.allocationOf(nftId).amounts;
-       uint256[] memory claimedSeconds = vesting.allocationOf(nftId).claimedSeconds;
-       uint256[] memory vestingPeriods = vesting.allocationOf(nftId).vestingPeriods;
-       bool[] memory claimedFlows = vesting.allocationOf(nftId).claimedFlows;
-       uint256 len = vesting.allocationOf(nftId).amounts.length;
        
+       if (address(token) == address(vesting.getAllocationOf(nftId).token)) return 0;
+       uint256[] memory amounts = vesting.getAllocationOf(nftId).amounts;
+       uint256[] memory claimedSeconds = vesting.getAllocationOf(nftId).claimedSeconds;
+       uint256[] memory vestingPeriods = vesting.getAllocationOf(nftId).vestingPeriods;
+       bool[] memory claimedFlows = vesting.getAllocationOf(nftId).claimedFlows;
+       uint256 len = vesting.getAllocationOf(nftId).amounts.length;
        ...
    }
```

This way, `A26ZDividendDistributor` receives the full Allocation struct via a correctly defined ABI and will no longer revert due to the ABI mismatch.
  