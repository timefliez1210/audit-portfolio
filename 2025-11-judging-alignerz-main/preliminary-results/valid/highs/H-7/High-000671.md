# [000671] Infinite loop causing a full DoS of `calculateFeeAndNewAmountForOneTVS()`
  
  ### Summary

The missing increment of the loop counter `i` will cause an infinite loop, resulting in a permanent DoS for any function that calls `calculateFeeAndNewAmountForOneTVS()`.
Because `mergeTVS()` and `splitTVS()` rely on this function, any attempt to merge or split a TVS will always revert, preventing users from performing TVS management operations.

### Root Cause

https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L170
In `calculateFeeAndNewAmountForOneTVS()`, the for loop is declared as:
```solidity
for (uint256 i; i < length;) {
```
But `i` is never incremented inside the loop.
This causes an infinite loop, consuming all available gas and forcing the EVM to revert.

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

1. User calls `mergeTVS()` or `splitTVS()`.
2. The function calls `calculateFeeAndNewAmountForOneTVS()`.
3. The loop begins and never increments i.
4. Execution consumes all gas.
5. The transaction reverts.
6. User cannot complete the action
7. All TVS management functionality becomes permanently unusable.

### Impact

- Users cannot merge TVSs.
- Users cannot split TVSs.
- Any protocol logic relying on these functions is broken.

### PoC

1. To avoid having the array out-of-bounds error, you have to unitialize first `newAmounts` in `calculateFeeAndNewAmountForOneTVS()` :
```solidity
    function calculateFeeAndNewAmountForOneTVS(
        uint256 feeRate,
        uint256[] memory amounts,
        uint256 length
    ) public pure returns (uint256 feeAmount, uint256[] memory newAmounts) {
        newAmounts = new uint256[](length); // <<< Line to add
        for (uint256 i; i < length; ) {
            feeAmount += calculateFeeAmount(feeRate, amounts[i]);
            newAmounts[i] = amounts[i] - feeAmount;
        }
    }
```
2. Add the following test in AlignerzVestingProtocolTest.t.sol and run the following command :
```solidity 
forge test --match-test test2calculateFeeAndNewAmountForOneTVS
```
```solidity
    function test2calculateFeeAndNewAmountForOneTVS() public {
        uint feeRate = 300; //3%
        uint256 length = 5;

        uint256[] memory amounts = new uint256[](length);

        amounts[0] = 1000;
        amounts[1] = 2000;
        amounts[2] = 3000;
        amounts[3] = 4000;
        amounts[4] = 5000;
        vm.expectRevert();
        vesting.calculateFeeAndNewAmountForOneTVS(feeRate, amounts, length);
    }
```
Note : If we remove the `vm.expectRevert()`, the infinite loop causes `feeAmount` to continuously accumulate without bounds, resulting in an arithmetic overflow.

### Mitigation

Increment `i` :
```solidity
for (uint256 i; i < length; i++) { <<<@
    feeAmount += calculateFeeAmount(feeRate, amounts[i]);
    newAmounts[i] = amounts[i] - feeAmount;
}
```
  