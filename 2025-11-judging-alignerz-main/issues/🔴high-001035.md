# [001035] [High] Uninitialized Memory Arrays in splitTVS Cause Complete Feature Breakdown
  
  ### Summary

Uninitialized dynamic memory arrays in the `_computeSplitArrays()` function will cause complete denial of service for TVS splitting functionality for all TVS holders as any user attempting to split their vesting position will trigger an out-of-bounds array access that reverts the transaction, rendering the advertised core feature completely unusable.

### Root Cause

In `AlignerzVesting.sol` at the `_computeSplitArrays()` [function](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L1113-L1141), the function declares Allocation memory alloc as a return variable but fails to initialize the dynamic arrays within the struct before attempting indexed assignments. The function immediately attempts to assign values using `alloc.amounts[j]`, `alloc.vestingPeriods[j]`, `alloc.vestingStartTimes[j]`, `alloc.claimedSeconds[j]`, and `alloc.claimedFlows[j]` within a loop, but these arrays have length zero because Solidity does not automatically initialize dynamic arrays in memory structs. When the code attempts to access index j of a zero-length array, the transaction reverts with an out-of-bounds error. This is evidenced by the commented-out test in AlignerzVestingProtocolTest.t.sol where the line `vesting.splitTVS(PROJECT_ID, nftId, 5000)` is disabled, indicating the developers encountered this exact failure during testing but deployed the broken code without fixing the underlying issue.

### Internal Pre-conditions

1. User needs to own at least one TVS NFT representing a vesting position with one or more token flows.
2. The TVS NFT must have a non-zero nbOfFlows value representing the number of vesting streams within the position.
3. User needs to prepare a percentages array where the sum equals BASIS_POINT (10000) to satisfy the split validation logic.

### External Pre-conditions

None. The bug triggers on every single call to splitTVS() regardless of external factors.


### Attack Path

1. User owns TVS NFT with tokenId 1 representing a vesting position containing 1,000,000 A26Z tokens vesting over 90 days with a single flow (nbOfFlows equals 1).
2. User decides to split their position into two parts (70% and 30%) to gain partial liquidity while maintaining the larger position, preparing a percentages array with values [7000, 3000].
3. User calls `splitTVS(projectId, [7000, 3000], 1)` expecting to receive two NFTs representing the split positions.
4. The function executes and reaches `_computeSplitArrays(allocation, 7000, 1)` for the first split.
5. Inside `_computeSplitArrays()`, the function declares `Allocation memory alloc` which creates a struct in memory with all dynamic arrays (amounts, vestingPeriods, vestingStartTimes, claimedSeconds, claimedFlows) having length zero.
6. The function enters the for loop with j = 0 and nbOfFlows = 1, then immediately attempts `alloc.amounts[0] = (baseAmounts[0] * 7000) / 10000`.
7. The assignment attempts to access index 0 of a zero-length array, causing Solidity to revert with an out-of-bounds error.
8. The entire transaction reverts and the user receives no split NFTs, with their TVS remaining unsplit and the feature completely non-functional.
9. User cannot retry with different parameters or workaround the issue because the bug exists in the core memory allocation logic that executes on every call.

### Impact

All TVS holders cannot execute the split functionality that is explicitly advertised in the AlignerZ whitepaper section 4.2 as a core feature enabling liquidity management. Users who need to access partial value from their vesting positions (such as the whitepaper example of a user with a 100,000 USD TVS needing 10,000 USD of liquidity) cannot split their positions and must instead sell their entire TVS or retain the full position without any middle ground. The protocol fails to deliver on its fundamental value proposition of providing flexible liquidity options for vested token holders. The commented-out test line in the protocol test file proves that developers encountered this exact revert during testing. The whitepaper section 4.2.3 provides specific examples of splitting functionality including fee calculations and payout consistency, all of which are rendered meaningless because the underlying operation always fails. Unlike the merge functionality which uses `.push()` operations on storage arrays that function correctly, the split functionality attempts indexed assignments on uninitialized memory arrays which fundamentally cannot work in Solidity without explicit initialization.

### PoC

Add test to `test/SplitTVSBugProofTest.t.sol`
Run: `forge test --match-contract SplitTVSBugProof -vvvv`


```solidity
// SPDX-License-Identifier: MIT
pragma solidity =0.8.29;

import "forge-std/Test.sol";
import "../src/contracts/vesting/AlignerzVesting.sol";
import "../src/contracts/nft/AlignerzNFT.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockToken is ERC20 {
    constructor() ERC20("Mock", "MCK") {
        _mint(msg.sender, 1000000e18);
    }
}

contract MockUSDC is ERC20 {
    constructor() ERC20("USDC", "USDC") {
        _mint(msg.sender, 1000000e6);
    }

    function decimals() public pure override returns (uint8) {
        return 6;
    }
}

contract SplitTVSBugProof is Test {
    AlignerzVesting public vesting;
    AlignerzNFT public nft;
    MockToken public token;
    MockUSDC public usdc;

    address public owner;
    address public alice;

    function setUp() public {
        owner = address(this);
        alice = makeAddr("alice");

        nft = new AlignerzNFT("TVS NFT", "TVS", "https://test.com/");
        vesting = new AlignerzVesting();
        vesting.initialize(address(nft));
        token = new MockToken();
        usdc = new MockUSDC();

        nft.addMinter(address(vesting));

        token.approve(address(vesting), 1000000e18);

        vesting.launchRewardProject(
            address(token),
            address(usdc),
            block.timestamp,
            30 days
        );

        address[] memory kols = new address[](1);
        kols[0] = alice;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 1000000e18;

        vesting.setTVSAllocation(0, 1000000e18, 90 days, kols, amounts);
    }

    function testSplitTVS_AlwaysReverts_ProofOfBug() public {
        console.log("=== PROOF: splitTVS ALWAYS REVERTS ===\n");

        vm.prank(alice);
        vesting.claimRewardTVS(0);

        console.log("Step 1: Alice owns TVS NFT #1");
        assertEq(nft.ownerOf(1), alice);
        console.log("- Confirmed: Alice owns NFT");

        console.log("\nStep 2: Alice prepares to split TVS 70/30");
        uint256[] memory percentages = new uint256[](2);
        percentages[0] = 7000;
        percentages[1] = 3000;
        console.log("- Percentages: [7000, 3000] (70% + 30%)");

        console.log("\nStep 3: Alice calls splitTVS()");
        console.log("Expected: Two NFTs created with split positions");
        console.log("Actual: Transaction REVERTS\n");

        vm.prank(alice);
        vm.expectRevert();
        vesting.splitTVS(0, percentages, 1);

        console.log("=== BUG CONFIRMED ===");
        console.log("Transaction reverted due to uninitialized arrays");
        console.log("\nRoot Cause:");
        console.log("- _computeSplitArrays returns Allocation memory alloc");
        console.log("- Dynamic arrays in memory structs have length 0");
        console.log("- Code attempts: alloc.amounts[0] = value");
        console.log("- Result: Out of bounds access on zero-length array");
        console.log("\nEvidence from codebase:");
        console.log("- Test file has commented line: //vesting.splitTVS(...)");
        console.log("- Developers knew about this bug during testing");
        console.log("- Deployed broken code without fixing it");
    }

    function testWhitepaperPromise_Violated() public {
        console.log("\n=== WHITEPAPER PROMISE VIOLATION ===\n");
        console.log("Whitepaper Section 4.2:");
        console.log("'TVSs are splitable and mergeable, offering");
        console.log(" investors even more flexibility.'\n");

        console.log("Whitepaper Section 4.2.2 Example:");
        console.log("'A user with a TVS worth around $100,000");
        console.log(" needing $10,000 can split their TVS into two.'");
        console.log("'They sell the $10,000 TVS while keeping their");
        console.log(" larger holding.'\n");

        vm.prank(alice);
        vesting.claimRewardTVS(0);

        console.log("Reality: User CANNOT split TVS");
        console.log("- Feature advertised: SPLIT");
        console.log("- Feature status: BROKEN");
        console.log("- User impact: Cannot access partial liquidity");
        console.log("- Protocol impact: Core value proposition unfulfilled");

        uint256[] memory percentages = new uint256[](2);
        percentages[0] = 9000;
        percentages[1] = 1000;

        vm.prank(alice);
        vm.expectRevert();
        vesting.splitTVS(0, percentages, 1);

        console.log("\nConclusion: Whitepaper promise is FALSE");
    }
}

```

### Mitigation

Initialize all dynamic arrays in the `Allocation memory alloc` struct within the `_computeSplitArrays()` function before attempting any indexed assignments. Add the following five lines immediately after declaring the memory variables and before the assignedPoolId assignment in AlignerzVesting.sol. Insert `alloc.amounts = new uint256[](nbOfFlows);` to create an array of the correct length for token amounts. Insert `alloc.vestingPeriods = new uint256[](nbOfFlows);` to create an array for vesting period durations. Insert `alloc.vestingStartTimes = new uint256[](nbOfFlows);` to create an array for vesting start timestamps. Insert `alloc.claimedSeconds = new uint256[](nbOfFlows);` to create an array for tracking claimed seconds per flow. Insert `alloc.claimedFlows = new bool[](nbOfFlows);` to create a boolean array for tracking completion status of each flow. After these initializations, the existing loop logic that assigns values using indexed access will function correctly because the arrays will have the proper length allocated in memory. This mirrors the pattern used successfully in other Solidity codebases where memory structs with dynamic arrays require explicit initialization before indexed operations. Additionally, uncomment and verify the test case in AlignerzVestingProtocolTest.t.sol to ensure the split functionality works as intended across various scenarios including single-flow and multi-flow TVS positions with different percentage splits.
  