# [000797] Hardcoded Fee Limits May Become Incorrect After Future Upgrades
  
  ### Summary

The use of hardcoded numerical limits in setter functions will cause a misalignment between expected and enforced fee bounds for protocol operators as future upgrades modifying BASIS_POINT or related constants will invalidate the currently fixed threshold checks.


### Root Cause

The choice to use hardcoded absolute values as upper bounds for fee setter functions is a mistake as these limits do not scale with BASIS_POINT or other configuration values, making them fragile to upgrades and potentially incorrect in future versions.

Example reference:
- In `FeesManager.sol`, lines affecting `_setBidFee`, `_setUpdateBidFee`, `_setSplitFeeRate`, and `_setMergeFeeRate` enforce fixed limits such as `require(newBidFee < 100001)` or `require(newSplitFeeRate < 201)` instead of using a constant-based calculation.

[constant used in checks](https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/feesManager/FeesManager.sol#L86)

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

This is not an attack, it's informational.
1. The protocol is upgraded and `BASIS_POINT`, scaling logic, or fee calculation methods are modified.
2. The hardcoded limits (e.g., 100001, 201) no longer represent the intended relative thresholds.
3. Protocol operators attempt to adjust fees to new, valid values under the new system.
4. The transactions revert because the fixed thresholds are now inconsistent with the updated configuration.


### Impact

The protocol operators cannot update fee parameters to values that are valid under the updated configuration, resulting in configuration freeze and potential degradation of protocol functionality.  
Since this does not create a direct exploit path but affects maintainability and future compatibility, it is categorized as informational severity.


### PoC

_No response_

### Mitigation

Use relative, constant-driven limits instead of hardcoded numbers. 
This will ensure that future upgrades modifying global constants or fee logic remain compatible with the setter validation.

  