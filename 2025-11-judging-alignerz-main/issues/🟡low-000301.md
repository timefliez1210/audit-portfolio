# [000301] Lack of Project Validation in `claimTokens` Allows Permanent Token Loss
  
  User will lose their vested tokens permanently when incorrect projectId is provided

# Root Cause

In [`AlignerzVesting.sol`](https://github.com/dualguard/2025-11-alignerz/blob/f7eeed88d91356484c02af6f38b71f27b790828c/protocol/src/contracts/vesting/AlignerzVesting.sol#L860), the `claimTokens` function retrieves an allocation using user-provided `projectId` and `nftId` parameters without validating that the NFT actually belongs to that project, leading to access of uninitialized storage when wrong `projectId` is provided.

```solidity
function claimTokens(uint256 projectId, uint256 nftId) external {
    address nftOwner = nftContract.extOwnerOf(nftId);
    require(msg.sender == nftOwner, Caller_Should_Own_The_NFT());

    bool isBiddingProject = NFTBelongsToBiddingProject[nftId];

    //@audit-issue No validation that nftId exists in this projectId
    (Allocation storage allocation, IERC20 token) = isBiddingProject
        ? (biddingProjects[projectId].allocations[nftId],
           biddingProjects[projectId].token)
        : (rewardProjects[projectId].allocations[nftId],
           rewardProjects[projectId].token);

    uint256 nbOfFlows = allocation.vestingPeriods.length;  // = 0 if not in project

    // Loop doesn't execute when nbOfFlows = 0
    // flowsClaimed remains 0, nbOfFlows = 0

    if (flowsClaimed == nbOfFlows) {  // 0 == 0 → TRUE!
        nftContract.burn(nftId);
        allocation.isClaimed = true;
    }

    token.safeTransfer(msg.sender, claimableAmounts);  // Transfers 0 tokens
}
```

# Internal Pre-conditions

1. User needs to own an NFT with vesting allocation in Project #0 (or any valid project)
2. User needs to incorrectly call `claimTokens()` with mismatched parameters (example: `projectId: 5` when NFT is from Project # 0)
3. The accessed project (wrong projectId) must not have any allocation for this specific nftId (typical case)

# Vulnerability Path

1. User owns NFT # 1 which was minted from Project #0 with 10,000 tokens vesting
2. User attempts to claim tokens but provides wrong `projectId` parameter (mistakenly types "5" instead of "0", UI bug)
3. Function calls `claimTokens(projectId: 5, nftId: 1)`
4. Function verifies user owns NFT # 1 (check passes)
5. Function retrieves `allocation = biddingProjects[5].allocations[1]`
   - This accesses uninitialized storage (NFT # 1 not in Project # 5)
   - Returns empty struct with default values: `nbOfFlows = 0`
6. Loop condition `i < nbOfFlows` → `i < 0` → Loop never executes
   - `claimableAmounts` remains 0
   - `flowsClaimed` remains 0
7. Burn logic: `if (flowsClaimed == nbOfFlows)` → `if (0 == 0)` → TRUE
   - Calls `nftContract.burn(1)` → NFT # 1 permanently destroyed
   - Sets `biddingProjects[5].allocations[1].isClaimed = true` (wrong project!)
8. Transfer: `token.safeTransfer(msg.sender, 0)` → User receives nothing
9. Emits event showing successful "claim" with empty arrays
10. **Result**: NFT destroyed, 0 tokens received, 10,000 tokens in Project #0 locked forever

# Impact

Impact is Low as this issue stems from user mistake but still important to note that this possible mistake leads to loss of asset.
The user cannot claim their vested tokens as the NFT required for claiming is permanently burned. With NFT # 1 from Project #0 containing 10,000 vested tokens, providing wrong `projectId: 5` results in the NFT being destroyed while receiving 0 tokens. The 10,000 tokens remain locked in `biddingProjects[0].allocations[1]` with no recovery mechanism. Additionally, these unclaimed tokens are excluded from dividend calculations (as `safeOwnerOf(1)` returns false for burned NFTs), causing unfair redistribution to remaining holders.


# Mitigation

Add validation to ensure the NFT has an allocation in the provided `projectId` before processing:

```solidity
function claimTokens(uint256 projectId, uint256 nftId) external {
    address nftOwner = nftContract.extOwnerOf(nftId);
    require(msg.sender == nftOwner, Caller_Should_Own_The_NFT());

    bool isBiddingProject = NFTBelongsToBiddingProject[nftId];
    (Allocation storage allocation, IERC20 token) = isBiddingProject
        ? (biddingProjects[projectId].allocations[nftId],
           biddingProjects[projectId].token)
        : (rewardProjects[projectId].allocations[nftId],
           rewardProjects[projectId].token);

    uint256 nbOfFlows = allocation.vestingPeriods.length;

    require(nbOfFlows > 0, "NFT not allocated in this project");

    //@audit Add Fix: Additional validation for robustness
    require(address(allocation.token) != address(0), "Invalid allocation");
    require(address(allocation.token) == address(token), "Token mismatch");

    uint256 claimableAmounts;
    uint256[] memory amountsClaimed = new uint256[](nbOfFlows);
    uint256[] memory allClaimableSeconds = new uint256[](nbOfFlows);
    uint256 flowsClaimed;

    for (uint256 i; i < nbOfFlows; i++) {
        if (allocation.claimedFlows[i]) {
            flowsClaimed++;
            continue;
        }

        (uint256 claimableAmount, uint256 claimableSeconds) =
            getClaimableAmountAndSeconds(allocation, i);

        allocation.claimedSeconds[i] += claimableSeconds;

        if (allocation.claimedSeconds[i] >= allocation.vestingPeriods[i]) {
            flowsClaimed++;
            allocation.claimedFlows[i] = true;
        }

        allClaimableSeconds[i] = claimableSeconds;
        amountsClaimed[i] = claimableAmount;
        claimableAmounts += claimableAmount;
    }

    if (flowsClaimed == nbOfFlows) {
        nftContract.burn(nftId);
        allocation.isClaimed = true;
    }

    allocationOf[nftId] = allocation;  // Also fix H-01

    token.safeTransfer(msg.sender, claimableAmounts);
    emit TokensClaimed(
        projectId,
        isBiddingProject,
        allocation.assignedPoolId,
        allocation.isClaimed,
        nftId,
        allClaimableSeconds,
        block.timestamp,
        msg.sender,
        amountsClaimed
    );
}
```

  