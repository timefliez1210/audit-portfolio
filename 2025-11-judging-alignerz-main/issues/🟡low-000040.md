# [000040] Incorrect loop bound causes out-of-bounds access in distribution functions
  
  ### Summary

The `distributeRewardTVS()` and `distributeStablecoinAllocation()` functions are intended to allow the caller to pass an array of KOL addresses (`kol`) to distribute remaining allocations to, enabling **partial distribution** after the claim window. However, both functions determine the loop bound using the internal storage arrays (`kolTVSAddresses` / `kolStablecoinAddresses`) instead of the user-supplied `kol` array:

```solidity
uint256 len = rewardProject.kolTVSAddresses.length;
for (uint256 i; i < len; ) {
    _claimRewardTVS(rewardProjectId, kol[i]);
    unchecked { ++i; }
}
```

and

```solidity
uint256 len = rewardProject.kolStablecoinAddresses.length;
for (uint256 i; i < len; ) {
    _claimStablecoinAllocation(rewardProjectId, kol[i]);
    unchecked { ++i; }
}
```

This mismatch between `len` and the array actually being indexed can cause out-of-bounds reads when `kol.length < internalArray.length`.

### Root Cause


The loop bound is derived from the internal storage arrays, while indexing uses the calldata parameter.
* https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/AlignerzVesting.sol#L528-L529
* https://github.com/dualguard/2025-11-alignerz/blob/main/protocol/src/contracts/vesting/AlignerzVesting.sol#L543-L544

### Internal Pre-conditions

_No response_

### External Pre-conditions

_No response_

### Attack Path

N/A

### Impact

The functions may **revert** whenever `kol.length` is smaller than the corresponding internal array length, breaking the intended ability to distribute to a subset of KOLs.

### PoC

_No response_

### Mitigation

Consider aligning the loop bound with the actual array being indexed (`kol`) so partial distributions are correctly supported.
  