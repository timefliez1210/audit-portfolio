# [000745] [High - ðŸ”´]In Contract `AlignerzVesting.sol` function `mergeTVS(...)` double accounting of the `mergeFee`
  
  ### Summary

In Contract `AlignerzVesting.sol` function `mergeTVS(...)` double accounting of the `mergeFee` When we `User(msg.sender)` merging there TVS fee calculation we first calculate fee for first amount allocation . Then we collect fee for  other `nftIds[i]` that we are merging through the function `_merge(...)`

```solidity
function mergeTVS(uint256 projectId, uint256 mergedNftId, uint256[] calldata projectIds, uint256[] calldata nftIds) external returns(uint256) {
        // ...
        (uint256 feeAmount, uint256[] memory newAmounts) = calculateFeeAndNewAmountForOneTVS(mergeFeeRate, amounts, nbOfFlows);


        for (uint256 i; i < nbOfNFTs; i++) {
            feeAmount += _merge(mergedTVS, projectIds[i], nftIds[i], token); // @audit double account of merge fee 
        }
        token.safeTransfer(treasury, feeAmount); // fee transfer to treasury
        // ....
    }



function _merge(Allocation storage mergedTVS, uint256 projectId, uint256 nftId, IERC20 token) internal returns (uint256 feeAmount) {
        require(msg.sender == nftContract.extOwnerOf(nftId), Caller_Should_Own_The_NFT());
        
        bool isBiddingProjectTVSToMerge = NFTBelongsToBiddingProject[nftId];
        (Allocation storage TVSToMerge, IERC20 tokenToMerge) = isBiddingProjectTVSToMerge ?
        (biddingProjects[projectId].allocations[nftId], biddingProjects[projectId].token) :
        (rewardProjects[projectId].allocations[nftId], rewardProjects[projectId].token);
        require(address(token) == address(tokenToMerge), Different_Tokens());

        uint256 nbOfFlowsTVSToMerge = TVSToMerge.amounts.length;
        for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
            uint256 fee = calculateFeeAmount(mergeFeeRate, TVSToMerge.amounts[j]);
            mergedTVS.amounts.push(TVSToMerge.amounts[j] - fee); // here we also decrease the fee 
            // ...
            feeAmount += fee; // @audit here 
        }
        nftContract.burn(nftId);
    }
```

```
Final fee Amount look like this:
feeAmount = feeAmount + (fee (For MergeNfts))


For MergeNfts fee:
for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
      feeAmount  = feeAmount  + fee[i] (Fee for every merging Fee)
}

fee[i] = feeAmount + fee(1) + fee(2) + ....

Final Look of FeeAmount:

feeAmount  = feeAmount + (feeAmount + fee(1) + fee(2) + fee(3)+ ....)
```

Here we can see the `feeAmount ` is accounted two times in the `mergeTVS` function and we also reduce from the `mergedTVS.amounts`

```solidity
for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
            uint256 fee = calculateFeeAmount(mergeFeeRate, TVSToMerge.amounts[j]);
@>            mergedTVS.amounts.push(TVSToMerge.amounts[j] - fee); // also decrease the fee from the amounts 
            mergedTVS.vestingPeriods.push(TVSToMerge.vestingPeriods[j]);
            mergedTVS.vestingStartTimes.push(TVSToMerge.vestingStartTimes[j]);
            mergedTVS.claimedSeconds.push(TVSToMerge.claimedSeconds[j]);
            mergedTVS.claimedFlows.push(TVSToMerge.claimedFlows[j]);
            feeAmount += fee;
        }
```

### Root Cause

 
```solidity
   function mergeTVS(uint256 projectId, uint256 mergedNftId, uint256[] calldata projectIds, uint256[] calldata nftIds) external returns(uint256) {
        address nftOwner = nftContract.extOwnerOf(mergedNftId);
        require(msg.sender == nftOwner, Caller_Should_Own_The_NFT());
        
        bool isBiddingProject = NFTBelongsToBiddingProject[mergedNftId];
        (Allocation storage mergedTVS, IERC20 token) = isBiddingProject ?
        (biddingProjects[projectId].allocations[mergedNftId], biddingProjects[projectId].token) :
        (rewardProjects[projectId].allocations[mergedNftId], rewardProjects[projectId].token);

        uint256[] memory amounts = mergedTVS.amounts;
        uint256 nbOfFlows = mergedTVS.amounts.length;
 @>       (uint256 feeAmount, uint256[] memory newAmounts) = calculateFeeAndNewAmountForOneTVS(mergeFeeRate, amounts, nbOfFlows);
        mergedTVS.amounts = newAmounts;

        uint256 nbOfNFTs = nftIds.length;
        require(nbOfNFTs > 0, Not_Enough_TVS_To_Merge());
        require(nbOfNFTs == projectIds.length, Array_Lengths_Must_Match());

        for (uint256 i; i < nbOfNFTs; i++) {
@>            feeAmount += _merge(mergedTVS, projectIds[i], nftIds[i], token);
        }
        token.safeTransfer(treasury, feeAmount);
        emit TVSsMerged(projectId, isBiddingProject, nftIds, mergedNftId, mergedTVS.amounts, mergedTVS.vestingPeriods, mergedTVS.vestingStartTimes, mergedTVS.claimedSeconds, mergedTVS.claimedFlows);
        return mergedNftId;
    }

    function _merge(Allocation storage mergedTVS, uint256 projectId, uint256 nftId, IERC20 token) internal returns (uint256 feeAmount) {
        require(msg.sender == nftContract.extOwnerOf(nftId), Caller_Should_Own_The_NFT());
        
        bool isBiddingProjectTVSToMerge = NFTBelongsToBiddingProject[nftId];
        (Allocation storage TVSToMerge, IERC20 tokenToMerge) = isBiddingProjectTVSToMerge ?
        (biddingProjects[projectId].allocations[nftId], biddingProjects[projectId].token) :
        (rewardProjects[projectId].allocations[nftId], rewardProjects[projectId].token);
        require(address(token) == address(tokenToMerge), Different_Tokens());

        uint256 nbOfFlowsTVSToMerge = TVSToMerge.amounts.length;
        for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
            uint256 fee = calculateFeeAmount(mergeFeeRate, TVSToMerge.amounts[j]);
@>       mergedTVS.amounts.push(TVSToMerge.amounts[j] - fee);
            mergedTVS.vestingPeriods.push(TVSToMerge.vestingPeriods[j]);
            mergedTVS.vestingStartTimes.push(TVSToMerge.vestingStartTimes[j]);
            mergedTVS.claimedSeconds.push(TVSToMerge.claimedSeconds[j]);
            mergedTVS.claimedFlows.push(TVSToMerge.claimedFlows[j]);
@>        feeAmount += fee;
        }
        nftContract.burn(nftId);
    }

```

### Internal Pre-conditions

None 

### External Pre-conditions

None

### Attack Path

None

### Impact

High - Because there is no need of any condition . This happen every time when user(msg.sender) calls the `mergeTVS` functionality 

### PoC

```
Final fee Amount look like this:
feeAmount = feeAmount + (fee (For MergeNfts))


For MergeNfts fee:
for (uint256 j = 0; j < nbOfFlowsTVSToMerge; j++) {
      feeAmount  = feeAmount  + fee[i] (Fee for every merging Fee)
}

Final Look of FeeAmount:

feeAmount  = feeAmount + (feeAmount + fee(1) + fee(2) + fee(3)+ ....)
```

Here we acn see there double account of `feeAmount` that is first fee that is accounted 

### Mitigation

None
  